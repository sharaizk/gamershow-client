{"ast":null,"code":"import _classCallCheck from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport PlayerEvents from './player-events.js';\nimport Transmuxer from '../core/transmuxer.js';\nimport TransmuxingEvents from '../core/transmuxing-events.js';\nimport MSEController from '../core/mse-controller.js';\nimport MSEEvents from '../core/mse-events.js';\nimport { ErrorTypes, ErrorDetails } from './player-errors.js';\nimport { createDefaultConfig } from '../config.js';\nimport { InvalidArgumentException, IllegalStateException } from '../utils/exception.js';\n\nvar FlvPlayer = /*#__PURE__*/function () {\n  function FlvPlayer(mediaDataSource, config) {\n    _classCallCheck(this, FlvPlayer);\n\n    this.TAG = 'FlvPlayer';\n    this._type = 'FlvPlayer';\n    this._emitter = new EventEmitter();\n    this._config = createDefaultConfig();\n\n    if (typeof config === 'object') {\n      Object.assign(this._config, config);\n    }\n\n    if (mediaDataSource.type.toLowerCase() !== 'flv') {\n      throw new InvalidArgumentException('FlvPlayer requires an flv MediaDataSource input!');\n    }\n\n    if (mediaDataSource.isLive === true) {\n      this._config.isLive = true;\n    }\n\n    this.e = {\n      onvLoadedMetadata: this._onvLoadedMetadata.bind(this),\n      onvSeeking: this._onvSeeking.bind(this),\n      onvCanPlay: this._onvCanPlay.bind(this),\n      onvStalled: this._onvStalled.bind(this),\n      onvProgress: this._onvProgress.bind(this)\n    };\n\n    if (self.performance && self.performance.now) {\n      this._now = self.performance.now.bind(self.performance);\n    } else {\n      this._now = Date.now;\n    }\n\n    this._pendingSeekTime = null; // in seconds\n\n    this._requestSetTime = false;\n    this._seekpointRecord = null;\n    this._progressChecker = null;\n    this._mediaDataSource = mediaDataSource;\n    this._mediaElement = null;\n    this._msectl = null;\n    this._transmuxer = null;\n    this._mseSourceOpened = false;\n    this._hasPendingLoad = false;\n    this._receivedCanPlay = false;\n    this._mediaInfo = null;\n    this._statisticsInfo = null;\n    var chromeNeedIDRFix = Browser.chrome && (Browser.version.major < 50 || Browser.version.major === 50 && Browser.version.build < 2661);\n    this._alwaysSeekKeyframe = chromeNeedIDRFix || Browser.msedge || Browser.msie ? true : false;\n\n    if (this._alwaysSeekKeyframe) {\n      this._config.accurateSeek = false;\n    }\n  }\n\n  _createClass(FlvPlayer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._progressChecker != null) {\n        window.clearInterval(this._progressChecker);\n        this._progressChecker = null;\n      }\n\n      if (this._transmuxer) {\n        this.unload();\n      }\n\n      if (this._mediaElement) {\n        this.detachMediaElement();\n      }\n\n      this.e = null;\n      this._mediaDataSource = null;\n\n      this._emitter.removeAllListeners();\n\n      this._emitter = null;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      var _this = this;\n\n      if (event === PlayerEvents.MEDIA_INFO) {\n        if (this._mediaInfo != null) {\n          Promise.resolve().then(function () {\n            _this._emitter.emit(PlayerEvents.MEDIA_INFO, _this.mediaInfo);\n          });\n        }\n      } else if (event === PlayerEvents.STATISTICS_INFO) {\n        if (this._statisticsInfo != null) {\n          Promise.resolve().then(function () {\n            _this._emitter.emit(PlayerEvents.STATISTICS_INFO, _this.statisticsInfo);\n          });\n        }\n      }\n\n      this._emitter.addListener(event, listener);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this._emitter.removeListener(event, listener);\n    }\n  }, {\n    key: \"attachMediaElement\",\n    value: function attachMediaElement(mediaElement) {\n      var _this2 = this;\n\n      this._mediaElement = mediaElement;\n      mediaElement.addEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n      mediaElement.addEventListener('seeking', this.e.onvSeeking);\n      mediaElement.addEventListener('canplay', this.e.onvCanPlay);\n      mediaElement.addEventListener('stalled', this.e.onvStalled);\n      mediaElement.addEventListener('progress', this.e.onvProgress);\n      this._msectl = new MSEController(this._config);\n\n      this._msectl.on(MSEEvents.UPDATE_END, this._onmseUpdateEnd.bind(this));\n\n      this._msectl.on(MSEEvents.BUFFER_FULL, this._onmseBufferFull.bind(this));\n\n      this._msectl.on(MSEEvents.SOURCE_OPEN, function () {\n        _this2._mseSourceOpened = true;\n\n        if (_this2._hasPendingLoad) {\n          _this2._hasPendingLoad = false;\n\n          _this2.load();\n        }\n      });\n\n      this._msectl.on(MSEEvents.ERROR, function (info) {\n        _this2._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, ErrorDetails.MEDIA_MSE_ERROR, info);\n      });\n\n      this._msectl.attachMediaElement(mediaElement);\n\n      if (this._pendingSeekTime != null) {\n        try {\n          mediaElement.currentTime = this._pendingSeekTime;\n          this._pendingSeekTime = null;\n        } catch (e) {// IE11 may throw InvalidStateError if readyState === 0\n          // We can defer set currentTime operation after loadedmetadata\n        }\n      }\n    }\n  }, {\n    key: \"detachMediaElement\",\n    value: function detachMediaElement() {\n      if (this._mediaElement) {\n        this._msectl.detachMediaElement();\n\n        this._mediaElement.removeEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n\n        this._mediaElement.removeEventListener('seeking', this.e.onvSeeking);\n\n        this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n\n        this._mediaElement.removeEventListener('stalled', this.e.onvStalled);\n\n        this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n\n        this._mediaElement = null;\n      }\n\n      if (this._msectl) {\n        this._msectl.destroy();\n\n        this._msectl = null;\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this3 = this;\n\n      if (!this._mediaElement) {\n        throw new IllegalStateException('HTMLMediaElement must be attached before load()!');\n      }\n\n      if (this._transmuxer) {\n        throw new IllegalStateException('FlvPlayer.load() has been called, please call unload() first!');\n      }\n\n      if (this._hasPendingLoad) {\n        return;\n      }\n\n      if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === false) {\n        this._hasPendingLoad = true;\n        return;\n      }\n\n      if (this._mediaElement.readyState > 0) {\n        this._requestSetTime = true; // IE11 may throw InvalidStateError if readyState === 0\n\n        this._mediaElement.currentTime = 0;\n      }\n\n      this._transmuxer = new Transmuxer(this._mediaDataSource, this._config);\n\n      this._transmuxer.on(TransmuxingEvents.INIT_SEGMENT, function (type, is) {\n        _this3._msectl.appendInitSegment(is);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.MEDIA_SEGMENT, function (type, ms) {\n        _this3._msectl.appendMediaSegment(ms); // lazyLoad check\n\n\n        if (_this3._config.lazyLoad && !_this3._config.isLive) {\n          var currentTime = _this3._mediaElement.currentTime;\n\n          if (ms.info.endDts >= (currentTime + _this3._config.lazyLoadMaxDuration) * 1000) {\n            if (_this3._progressChecker == null) {\n              Log.v(_this3.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n\n              _this3._suspendTransmuxer();\n            }\n          }\n        }\n      });\n\n      this._transmuxer.on(TransmuxingEvents.LOADING_COMPLETE, function () {\n        _this3._msectl.endOfStream();\n\n        _this3._emitter.emit(PlayerEvents.LOADING_COMPLETE);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.RECOVERED_EARLY_EOF, function () {\n        _this3._emitter.emit(PlayerEvents.RECOVERED_EARLY_EOF);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.IO_ERROR, function (detail, info) {\n        _this3._emitter.emit(PlayerEvents.ERROR, ErrorTypes.NETWORK_ERROR, detail, info);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.DEMUX_ERROR, function (detail, info) {\n        _this3._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, detail, {\n          code: -1,\n          msg: info\n        });\n      });\n\n      this._transmuxer.on(TransmuxingEvents.MEDIA_INFO, function (mediaInfo) {\n        _this3._mediaInfo = mediaInfo;\n\n        _this3._emitter.emit(PlayerEvents.MEDIA_INFO, Object.assign({}, mediaInfo));\n      });\n\n      this._transmuxer.on(TransmuxingEvents.METADATA_ARRIVED, function (metadata) {\n        _this3._emitter.emit(PlayerEvents.METADATA_ARRIVED, metadata);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.SCRIPTDATA_ARRIVED, function (data) {\n        _this3._emitter.emit(PlayerEvents.SCRIPTDATA_ARRIVED, data);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.STATISTICS_INFO, function (statInfo) {\n        _this3._statisticsInfo = _this3._fillStatisticsInfo(statInfo);\n\n        _this3._emitter.emit(PlayerEvents.STATISTICS_INFO, Object.assign({}, _this3._statisticsInfo));\n      });\n\n      this._transmuxer.on(TransmuxingEvents.RECOMMEND_SEEKPOINT, function (milliseconds) {\n        if (_this3._mediaElement && !_this3._config.accurateSeek) {\n          _this3._requestSetTime = true;\n          _this3._mediaElement.currentTime = milliseconds / 1000;\n        }\n      });\n\n      this._transmuxer.open();\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      if (this._mediaElement) {\n        this._mediaElement.pause();\n      }\n\n      if (this._msectl) {\n        this._msectl.seek(0);\n      }\n\n      if (this._transmuxer) {\n        this._transmuxer.close();\n\n        this._transmuxer.destroy();\n\n        this._transmuxer = null;\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      return this._mediaElement.play();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._mediaElement.pause();\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"buffered\",\n    get: function get() {\n      return this._mediaElement.buffered;\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      return this._mediaElement.duration;\n    }\n  }, {\n    key: \"volume\",\n    get: function get() {\n      return this._mediaElement.volume;\n    },\n    set: function set(value) {\n      this._mediaElement.volume = value;\n    }\n  }, {\n    key: \"muted\",\n    get: function get() {\n      return this._mediaElement.muted;\n    },\n    set: function set(muted) {\n      this._mediaElement.muted = muted;\n    }\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      if (this._mediaElement) {\n        return this._mediaElement.currentTime;\n      }\n\n      return 0;\n    },\n    set: function set(seconds) {\n      if (this._mediaElement) {\n        this._internalSeek(seconds);\n      } else {\n        this._pendingSeekTime = seconds;\n      }\n    }\n  }, {\n    key: \"mediaInfo\",\n    get: function get() {\n      return Object.assign({}, this._mediaInfo);\n    }\n  }, {\n    key: \"statisticsInfo\",\n    get: function get() {\n      if (this._statisticsInfo == null) {\n        this._statisticsInfo = {};\n      }\n\n      this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo);\n      return Object.assign({}, this._statisticsInfo);\n    }\n  }, {\n    key: \"_fillStatisticsInfo\",\n    value: function _fillStatisticsInfo(statInfo) {\n      statInfo.playerType = this._type;\n\n      if (!(this._mediaElement instanceof HTMLVideoElement)) {\n        return statInfo;\n      }\n\n      var hasQualityInfo = true;\n      var decoded = 0;\n      var dropped = 0;\n\n      if (this._mediaElement.getVideoPlaybackQuality) {\n        var quality = this._mediaElement.getVideoPlaybackQuality();\n\n        decoded = quality.totalVideoFrames;\n        dropped = quality.droppedVideoFrames;\n      } else if (this._mediaElement.webkitDecodedFrameCount != undefined) {\n        decoded = this._mediaElement.webkitDecodedFrameCount;\n        dropped = this._mediaElement.webkitDroppedFrameCount;\n      } else {\n        hasQualityInfo = false;\n      }\n\n      if (hasQualityInfo) {\n        statInfo.decodedFrames = decoded;\n        statInfo.droppedFrames = dropped;\n      }\n\n      return statInfo;\n    }\n  }, {\n    key: \"_onmseUpdateEnd\",\n    value: function _onmseUpdateEnd() {\n      if (!this._config.lazyLoad || this._config.isLive) {\n        return;\n      }\n\n      var buffered = this._mediaElement.buffered;\n      var currentTime = this._mediaElement.currentTime;\n      var currentRangeStart = 0;\n      var currentRangeEnd = 0;\n\n      for (var i = 0; i < buffered.length; i++) {\n        var start = buffered.start(i);\n        var end = buffered.end(i);\n\n        if (start <= currentTime && currentTime < end) {\n          currentRangeStart = start;\n          currentRangeEnd = end;\n          break;\n        }\n      }\n\n      if (currentRangeEnd >= currentTime + this._config.lazyLoadMaxDuration && this._progressChecker == null) {\n        Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n\n        this._suspendTransmuxer();\n      }\n    }\n  }, {\n    key: \"_onmseBufferFull\",\n    value: function _onmseBufferFull() {\n      Log.v(this.TAG, 'MSE SourceBuffer is full, suspend transmuxing task');\n\n      if (this._progressChecker == null) {\n        this._suspendTransmuxer();\n      }\n    }\n  }, {\n    key: \"_suspendTransmuxer\",\n    value: function _suspendTransmuxer() {\n      if (this._transmuxer) {\n        this._transmuxer.pause();\n\n        if (this._progressChecker == null) {\n          this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1000);\n        }\n      }\n    }\n  }, {\n    key: \"_checkProgressAndResume\",\n    value: function _checkProgressAndResume() {\n      var currentTime = this._mediaElement.currentTime;\n      var buffered = this._mediaElement.buffered;\n      var needResume = false;\n\n      for (var i = 0; i < buffered.length; i++) {\n        var from = buffered.start(i);\n        var to = buffered.end(i);\n\n        if (currentTime >= from && currentTime < to) {\n          if (currentTime >= to - this._config.lazyLoadRecoverDuration) {\n            needResume = true;\n          }\n\n          break;\n        }\n      }\n\n      if (needResume) {\n        window.clearInterval(this._progressChecker);\n        this._progressChecker = null;\n\n        if (needResume) {\n          Log.v(this.TAG, 'Continue loading from paused position');\n\n          this._transmuxer.resume();\n        }\n      }\n    }\n  }, {\n    key: \"_isTimepointBuffered\",\n    value: function _isTimepointBuffered(seconds) {\n      var buffered = this._mediaElement.buffered;\n\n      for (var i = 0; i < buffered.length; i++) {\n        var from = buffered.start(i);\n        var to = buffered.end(i);\n\n        if (seconds >= from && seconds < to) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_internalSeek\",\n    value: function _internalSeek(seconds) {\n      var directSeek = this._isTimepointBuffered(seconds);\n\n      var directSeekBegin = false;\n      var directSeekBeginTime = 0;\n\n      if (seconds < 1.0 && this._mediaElement.buffered.length > 0) {\n        var videoBeginTime = this._mediaElement.buffered.start(0);\n\n        if (videoBeginTime < 1.0 && seconds < videoBeginTime || Browser.safari) {\n          directSeekBegin = true; // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n\n          directSeekBeginTime = Browser.safari ? 0.1 : videoBeginTime;\n        }\n      }\n\n      if (directSeekBegin) {\n        // seek to video begin, set currentTime directly if beginPTS buffered\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = directSeekBeginTime;\n      } else if (directSeek) {\n        // buffered position\n        if (!this._alwaysSeekKeyframe) {\n          this._requestSetTime = true;\n          this._mediaElement.currentTime = seconds;\n        } else {\n          var idr = this._msectl.getNearestKeyframe(Math.floor(seconds * 1000));\n\n          this._requestSetTime = true;\n\n          if (idr != null) {\n            this._mediaElement.currentTime = idr.dts / 1000;\n          } else {\n            this._mediaElement.currentTime = seconds;\n          }\n        }\n\n        if (this._progressChecker != null) {\n          this._checkProgressAndResume();\n        }\n      } else {\n        if (this._progressChecker != null) {\n          window.clearInterval(this._progressChecker);\n          this._progressChecker = null;\n        }\n\n        this._msectl.seek(seconds);\n\n        this._transmuxer.seek(Math.floor(seconds * 1000)); // in milliseconds\n        // no need to set mediaElement.currentTime if non-accurateSeek,\n        // just wait for the recommend_seekpoint callback\n\n\n        if (this._config.accurateSeek) {\n          this._requestSetTime = true;\n          this._mediaElement.currentTime = seconds;\n        }\n      }\n    }\n  }, {\n    key: \"_checkAndApplyUnbufferedSeekpoint\",\n    value: function _checkAndApplyUnbufferedSeekpoint() {\n      if (this._seekpointRecord) {\n        if (this._seekpointRecord.recordTime <= this._now() - 100) {\n          var target = this._mediaElement.currentTime;\n          this._seekpointRecord = null;\n\n          if (!this._isTimepointBuffered(target)) {\n            if (this._progressChecker != null) {\n              window.clearTimeout(this._progressChecker);\n              this._progressChecker = null;\n            } // .currentTime is consists with .buffered timestamp\n            // Chrome/Edge use DTS, while FireFox/Safari use PTS\n\n\n            this._msectl.seek(target);\n\n            this._transmuxer.seek(Math.floor(target * 1000)); // set currentTime if accurateSeek, or wait for recommend_seekpoint callback\n\n\n            if (this._config.accurateSeek) {\n              this._requestSetTime = true;\n              this._mediaElement.currentTime = target;\n            }\n          }\n        } else {\n          window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n        }\n      }\n    }\n  }, {\n    key: \"_checkAndResumeStuckPlayback\",\n    value: function _checkAndResumeStuckPlayback(stalled) {\n      var media = this._mediaElement;\n\n      if (stalled || !this._receivedCanPlay || media.readyState < 2) {\n        // HAVE_CURRENT_DATA\n        var buffered = media.buffered;\n\n        if (buffered.length > 0 && media.currentTime < buffered.start(0)) {\n          Log.w(this.TAG, \"Playback seems stuck at \".concat(media.currentTime, \", seek to \").concat(buffered.start(0)));\n          this._requestSetTime = true;\n          this._mediaElement.currentTime = buffered.start(0);\n\n          this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n        }\n      } else {\n        // Playback didn't stuck, remove progress event listener\n        this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n      }\n    }\n  }, {\n    key: \"_onvLoadedMetadata\",\n    value: function _onvLoadedMetadata(e) {\n      if (this._pendingSeekTime != null) {\n        this._mediaElement.currentTime = this._pendingSeekTime;\n        this._pendingSeekTime = null;\n      }\n    }\n  }, {\n    key: \"_onvSeeking\",\n    value: function _onvSeeking(e) {\n      // handle seeking request from browser's progress bar\n      var target = this._mediaElement.currentTime;\n      var buffered = this._mediaElement.buffered;\n\n      if (this._requestSetTime) {\n        this._requestSetTime = false;\n        return;\n      }\n\n      if (target < 1.0 && buffered.length > 0) {\n        // seek to video begin, set currentTime directly if beginPTS buffered\n        var videoBeginTime = buffered.start(0);\n\n        if (videoBeginTime < 1.0 && target < videoBeginTime || Browser.safari) {\n          this._requestSetTime = true; // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n\n          this._mediaElement.currentTime = Browser.safari ? 0.1 : videoBeginTime;\n          return;\n        }\n      }\n\n      if (this._isTimepointBuffered(target)) {\n        if (this._alwaysSeekKeyframe) {\n          var idr = this._msectl.getNearestKeyframe(Math.floor(target * 1000));\n\n          if (idr != null) {\n            this._requestSetTime = true;\n            this._mediaElement.currentTime = idr.dts / 1000;\n          }\n        }\n\n        if (this._progressChecker != null) {\n          this._checkProgressAndResume();\n        }\n\n        return;\n      }\n\n      this._seekpointRecord = {\n        seekPoint: target,\n        recordTime: this._now()\n      };\n      window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n    }\n  }, {\n    key: \"_onvCanPlay\",\n    value: function _onvCanPlay(e) {\n      this._receivedCanPlay = true;\n\n      this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n    }\n  }, {\n    key: \"_onvStalled\",\n    value: function _onvStalled(e) {\n      this._checkAndResumeStuckPlayback(true);\n    }\n  }, {\n    key: \"_onvProgress\",\n    value: function _onvProgress(e) {\n      this._checkAndResumeStuckPlayback();\n    }\n  }]);\n\n  return FlvPlayer;\n}();\n\nexport default FlvPlayer;","map":{"version":3,"sources":["D:/STREAMING_SITE/client/node_modules/flv.js/src/player/flv-player.js"],"names":["EventEmitter","Log","Browser","PlayerEvents","Transmuxer","TransmuxingEvents","MSEController","MSEEvents","ErrorTypes","ErrorDetails","createDefaultConfig","InvalidArgumentException","IllegalStateException","FlvPlayer","mediaDataSource","config","TAG","_type","_emitter","_config","Object","assign","type","toLowerCase","isLive","e","onvLoadedMetadata","_onvLoadedMetadata","bind","onvSeeking","_onvSeeking","onvCanPlay","_onvCanPlay","onvStalled","_onvStalled","onvProgress","_onvProgress","self","performance","now","_now","Date","_pendingSeekTime","_requestSetTime","_seekpointRecord","_progressChecker","_mediaDataSource","_mediaElement","_msectl","_transmuxer","_mseSourceOpened","_hasPendingLoad","_receivedCanPlay","_mediaInfo","_statisticsInfo","chromeNeedIDRFix","chrome","version","major","build","_alwaysSeekKeyframe","msedge","msie","accurateSeek","window","clearInterval","unload","detachMediaElement","removeAllListeners","event","listener","MEDIA_INFO","Promise","resolve","then","emit","mediaInfo","STATISTICS_INFO","statisticsInfo","addListener","removeListener","mediaElement","addEventListener","on","UPDATE_END","_onmseUpdateEnd","BUFFER_FULL","_onmseBufferFull","SOURCE_OPEN","load","ERROR","info","MEDIA_ERROR","MEDIA_MSE_ERROR","attachMediaElement","currentTime","removeEventListener","destroy","deferLoadAfterSourceOpen","readyState","INIT_SEGMENT","is","appendInitSegment","MEDIA_SEGMENT","ms","appendMediaSegment","lazyLoad","endDts","lazyLoadMaxDuration","v","_suspendTransmuxer","LOADING_COMPLETE","endOfStream","RECOVERED_EARLY_EOF","IO_ERROR","detail","NETWORK_ERROR","DEMUX_ERROR","code","msg","METADATA_ARRIVED","metadata","SCRIPTDATA_ARRIVED","data","statInfo","_fillStatisticsInfo","RECOMMEND_SEEKPOINT","milliseconds","open","pause","seek","close","play","buffered","duration","volume","value","muted","seconds","_internalSeek","playerType","HTMLVideoElement","hasQualityInfo","decoded","dropped","getVideoPlaybackQuality","quality","totalVideoFrames","droppedVideoFrames","webkitDecodedFrameCount","undefined","webkitDroppedFrameCount","decodedFrames","droppedFrames","currentRangeStart","currentRangeEnd","i","length","start","end","setInterval","_checkProgressAndResume","needResume","from","to","lazyLoadRecoverDuration","resume","directSeek","_isTimepointBuffered","directSeekBegin","directSeekBeginTime","videoBeginTime","safari","idr","getNearestKeyframe","Math","floor","dts","recordTime","target","clearTimeout","setTimeout","_checkAndApplyUnbufferedSeekpoint","stalled","media","w","seekPoint","_checkAndResumeStuckPlayback"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport PlayerEvents from './player-events.js';\nimport Transmuxer from '../core/transmuxer.js';\nimport TransmuxingEvents from '../core/transmuxing-events.js';\nimport MSEController from '../core/mse-controller.js';\nimport MSEEvents from '../core/mse-events.js';\nimport {ErrorTypes, ErrorDetails} from './player-errors.js';\nimport {createDefaultConfig} from '../config.js';\nimport {InvalidArgumentException, IllegalStateException} from '../utils/exception.js';\n\nclass FlvPlayer {\n\n    constructor(mediaDataSource, config) {\n        this.TAG = 'FlvPlayer';\n        this._type = 'FlvPlayer';\n        this._emitter = new EventEmitter();\n\n        this._config = createDefaultConfig();\n        if (typeof config === 'object') {\n            Object.assign(this._config, config);\n        }\n\n        if (mediaDataSource.type.toLowerCase() !== 'flv') {\n            throw new InvalidArgumentException('FlvPlayer requires an flv MediaDataSource input!');\n        }\n\n        if (mediaDataSource.isLive === true) {\n            this._config.isLive = true;\n        }\n\n        this.e = {\n            onvLoadedMetadata: this._onvLoadedMetadata.bind(this),\n            onvSeeking: this._onvSeeking.bind(this),\n            onvCanPlay: this._onvCanPlay.bind(this),\n            onvStalled: this._onvStalled.bind(this),\n            onvProgress: this._onvProgress.bind(this)\n        };\n\n        if (self.performance && self.performance.now) {\n            this._now = self.performance.now.bind(self.performance);\n        } else {\n            this._now = Date.now;\n        }\n\n        this._pendingSeekTime = null;  // in seconds\n        this._requestSetTime = false;\n        this._seekpointRecord = null;\n        this._progressChecker = null;\n\n        this._mediaDataSource = mediaDataSource;\n        this._mediaElement = null;\n        this._msectl = null;\n        this._transmuxer = null;\n\n        this._mseSourceOpened = false;\n        this._hasPendingLoad = false;\n        this._receivedCanPlay = false;\n\n        this._mediaInfo = null;\n        this._statisticsInfo = null;\n\n        let chromeNeedIDRFix = (Browser.chrome &&\n                               (Browser.version.major < 50 ||\n                               (Browser.version.major === 50 && Browser.version.build < 2661)));\n        this._alwaysSeekKeyframe = (chromeNeedIDRFix || Browser.msedge || Browser.msie) ? true : false;\n\n        if (this._alwaysSeekKeyframe) {\n            this._config.accurateSeek = false;\n        }\n    }\n\n    destroy() {\n        if (this._progressChecker != null) {\n            window.clearInterval(this._progressChecker);\n            this._progressChecker = null;\n        }\n        if (this._transmuxer) {\n            this.unload();\n        }\n        if (this._mediaElement) {\n            this.detachMediaElement();\n        }\n        this.e = null;\n        this._mediaDataSource = null;\n\n        this._emitter.removeAllListeners();\n        this._emitter = null;\n    }\n\n    on(event, listener) {\n        if (event === PlayerEvents.MEDIA_INFO) {\n            if (this._mediaInfo != null) {\n                Promise.resolve().then(() => {\n                    this._emitter.emit(PlayerEvents.MEDIA_INFO, this.mediaInfo);\n                });\n            }\n        } else if (event === PlayerEvents.STATISTICS_INFO) {\n            if (this._statisticsInfo != null) {\n                Promise.resolve().then(() => {\n                    this._emitter.emit(PlayerEvents.STATISTICS_INFO, this.statisticsInfo);\n                });\n            }\n        }\n        this._emitter.addListener(event, listener);\n    }\n\n    off(event, listener) {\n        this._emitter.removeListener(event, listener);\n    }\n\n    attachMediaElement(mediaElement) {\n        this._mediaElement = mediaElement;\n        mediaElement.addEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n        mediaElement.addEventListener('seeking', this.e.onvSeeking);\n        mediaElement.addEventListener('canplay', this.e.onvCanPlay);\n        mediaElement.addEventListener('stalled', this.e.onvStalled);\n        mediaElement.addEventListener('progress', this.e.onvProgress);\n\n        this._msectl = new MSEController(this._config);\n\n        this._msectl.on(MSEEvents.UPDATE_END, this._onmseUpdateEnd.bind(this));\n        this._msectl.on(MSEEvents.BUFFER_FULL, this._onmseBufferFull.bind(this));\n        this._msectl.on(MSEEvents.SOURCE_OPEN, () => {\n            this._mseSourceOpened = true;\n            if (this._hasPendingLoad) {\n                this._hasPendingLoad = false;\n                this.load();\n            }\n        });\n        this._msectl.on(MSEEvents.ERROR, (info) => {\n            this._emitter.emit(PlayerEvents.ERROR,\n                               ErrorTypes.MEDIA_ERROR,\n                               ErrorDetails.MEDIA_MSE_ERROR,\n                               info\n            );\n        });\n\n        this._msectl.attachMediaElement(mediaElement);\n\n        if (this._pendingSeekTime != null) {\n            try {\n                mediaElement.currentTime = this._pendingSeekTime;\n                this._pendingSeekTime = null;\n            } catch (e) {\n                // IE11 may throw InvalidStateError if readyState === 0\n                // We can defer set currentTime operation after loadedmetadata\n            }\n        }\n    }\n\n    detachMediaElement() {\n        if (this._mediaElement) {\n            this._msectl.detachMediaElement();\n            this._mediaElement.removeEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n            this._mediaElement.removeEventListener('seeking', this.e.onvSeeking);\n            this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n            this._mediaElement.removeEventListener('stalled', this.e.onvStalled);\n            this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n            this._mediaElement = null;\n        }\n        if (this._msectl) {\n            this._msectl.destroy();\n            this._msectl = null;\n        }\n    }\n\n    load() {\n        if (!this._mediaElement) {\n            throw new IllegalStateException('HTMLMediaElement must be attached before load()!');\n        }\n        if (this._transmuxer) {\n            throw new IllegalStateException('FlvPlayer.load() has been called, please call unload() first!');\n        }\n        if (this._hasPendingLoad) {\n            return;\n        }\n\n        if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === false) {\n            this._hasPendingLoad = true;\n            return;\n        }\n\n        if (this._mediaElement.readyState > 0) {\n            this._requestSetTime = true;\n            // IE11 may throw InvalidStateError if readyState === 0\n            this._mediaElement.currentTime = 0;\n        }\n\n        this._transmuxer = new Transmuxer(this._mediaDataSource, this._config);\n\n        this._transmuxer.on(TransmuxingEvents.INIT_SEGMENT, (type, is) => {\n            this._msectl.appendInitSegment(is);\n        });\n        this._transmuxer.on(TransmuxingEvents.MEDIA_SEGMENT, (type, ms) => {\n            this._msectl.appendMediaSegment(ms);\n\n            // lazyLoad check\n            if (this._config.lazyLoad && !this._config.isLive) {\n                let currentTime = this._mediaElement.currentTime;\n                if (ms.info.endDts >= (currentTime + this._config.lazyLoadMaxDuration) * 1000) {\n                    if (this._progressChecker == null) {\n                        Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n                        this._suspendTransmuxer();\n                    }\n                }\n            }\n        });\n        this._transmuxer.on(TransmuxingEvents.LOADING_COMPLETE, () => {\n            this._msectl.endOfStream();\n            this._emitter.emit(PlayerEvents.LOADING_COMPLETE);\n        });\n        this._transmuxer.on(TransmuxingEvents.RECOVERED_EARLY_EOF, () => {\n            this._emitter.emit(PlayerEvents.RECOVERED_EARLY_EOF);\n        });\n        this._transmuxer.on(TransmuxingEvents.IO_ERROR, (detail, info) => {\n            this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.NETWORK_ERROR, detail, info);\n        });\n        this._transmuxer.on(TransmuxingEvents.DEMUX_ERROR, (detail, info) => {\n            this._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, detail, {code: -1, msg: info});\n        });\n        this._transmuxer.on(TransmuxingEvents.MEDIA_INFO, (mediaInfo) => {\n            this._mediaInfo = mediaInfo;\n            this._emitter.emit(PlayerEvents.MEDIA_INFO, Object.assign({}, mediaInfo));\n        });\n        this._transmuxer.on(TransmuxingEvents.METADATA_ARRIVED, (metadata) => {\n            this._emitter.emit(PlayerEvents.METADATA_ARRIVED, metadata);\n        });\n        this._transmuxer.on(TransmuxingEvents.SCRIPTDATA_ARRIVED, (data) => {\n            this._emitter.emit(PlayerEvents.SCRIPTDATA_ARRIVED, data);\n        });\n        this._transmuxer.on(TransmuxingEvents.STATISTICS_INFO, (statInfo) => {\n            this._statisticsInfo = this._fillStatisticsInfo(statInfo);\n            this._emitter.emit(PlayerEvents.STATISTICS_INFO, Object.assign({}, this._statisticsInfo));\n        });\n        this._transmuxer.on(TransmuxingEvents.RECOMMEND_SEEKPOINT, (milliseconds) => {\n            if (this._mediaElement && !this._config.accurateSeek) {\n                this._requestSetTime = true;\n                this._mediaElement.currentTime = milliseconds / 1000;\n            }\n        });\n\n        this._transmuxer.open();\n    }\n\n    unload() {\n        if (this._mediaElement) {\n            this._mediaElement.pause();\n        }\n        if (this._msectl) {\n            this._msectl.seek(0);\n        }\n        if (this._transmuxer) {\n            this._transmuxer.close();\n            this._transmuxer.destroy();\n            this._transmuxer = null;\n        }\n    }\n\n    play() {\n        return this._mediaElement.play();\n    }\n\n    pause() {\n        this._mediaElement.pause();\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    get buffered() {\n        return this._mediaElement.buffered;\n    }\n\n    get duration() {\n        return this._mediaElement.duration;\n    }\n\n    get volume() {\n        return this._mediaElement.volume;\n    }\n\n    set volume(value) {\n        this._mediaElement.volume = value;\n    }\n\n    get muted() {\n        return this._mediaElement.muted;\n    }\n\n    set muted(muted) {\n        this._mediaElement.muted = muted;\n    }\n\n    get currentTime() {\n        if (this._mediaElement) {\n            return this._mediaElement.currentTime;\n        }\n        return 0;\n    }\n\n    set currentTime(seconds) {\n        if (this._mediaElement) {\n            this._internalSeek(seconds);\n        } else {\n            this._pendingSeekTime = seconds;\n        }\n    }\n\n    get mediaInfo() {\n        return Object.assign({}, this._mediaInfo);\n    }\n\n    get statisticsInfo() {\n        if (this._statisticsInfo == null) {\n            this._statisticsInfo = {};\n        }\n        this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo);\n        return Object.assign({}, this._statisticsInfo);\n    }\n\n    _fillStatisticsInfo(statInfo) {\n        statInfo.playerType = this._type;\n\n        if (!(this._mediaElement instanceof HTMLVideoElement)) {\n            return statInfo;\n        }\n\n        let hasQualityInfo = true;\n        let decoded = 0;\n        let dropped = 0;\n\n        if (this._mediaElement.getVideoPlaybackQuality) {\n            let quality = this._mediaElement.getVideoPlaybackQuality();\n            decoded = quality.totalVideoFrames;\n            dropped = quality.droppedVideoFrames;\n        } else if (this._mediaElement.webkitDecodedFrameCount != undefined) {\n            decoded = this._mediaElement.webkitDecodedFrameCount;\n            dropped = this._mediaElement.webkitDroppedFrameCount;\n        } else {\n            hasQualityInfo = false;\n        }\n\n        if (hasQualityInfo) {\n            statInfo.decodedFrames = decoded;\n            statInfo.droppedFrames = dropped;\n        }\n\n        return statInfo;\n    }\n\n    _onmseUpdateEnd() {\n        if (!this._config.lazyLoad || this._config.isLive) {\n            return;\n        }\n\n        let buffered = this._mediaElement.buffered;\n        let currentTime = this._mediaElement.currentTime;\n        let currentRangeStart = 0;\n        let currentRangeEnd = 0;\n\n        for (let i = 0; i < buffered.length; i++) {\n            let start = buffered.start(i);\n            let end = buffered.end(i);\n            if (start <= currentTime && currentTime < end) {\n                currentRangeStart = start;\n                currentRangeEnd = end;\n                break;\n            }\n        }\n\n        if (currentRangeEnd >= currentTime + this._config.lazyLoadMaxDuration && this._progressChecker == null) {\n            Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n            this._suspendTransmuxer();\n        }\n    }\n\n    _onmseBufferFull() {\n        Log.v(this.TAG, 'MSE SourceBuffer is full, suspend transmuxing task');\n        if (this._progressChecker == null) {\n            this._suspendTransmuxer();\n        }\n    }\n\n    _suspendTransmuxer() {\n        if (this._transmuxer) {\n            this._transmuxer.pause();\n\n            if (this._progressChecker == null) {\n                this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1000);\n            }\n        }\n    }\n\n    _checkProgressAndResume() {\n        let currentTime = this._mediaElement.currentTime;\n        let buffered = this._mediaElement.buffered;\n\n        let needResume = false;\n\n        for (let i = 0; i < buffered.length; i++) {\n            let from = buffered.start(i);\n            let to = buffered.end(i);\n            if (currentTime >= from && currentTime < to) {\n                if (currentTime >= to - this._config.lazyLoadRecoverDuration) {\n                    needResume = true;\n                }\n                break;\n            }\n        }\n\n        if (needResume) {\n            window.clearInterval(this._progressChecker);\n            this._progressChecker = null;\n            if (needResume) {\n                Log.v(this.TAG, 'Continue loading from paused position');\n                this._transmuxer.resume();\n            }\n        }\n    }\n\n    _isTimepointBuffered(seconds) {\n        let buffered = this._mediaElement.buffered;\n\n        for (let i = 0; i < buffered.length; i++) {\n            let from = buffered.start(i);\n            let to = buffered.end(i);\n            if (seconds >= from && seconds < to) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _internalSeek(seconds) {\n        let directSeek = this._isTimepointBuffered(seconds);\n\n        let directSeekBegin = false;\n        let directSeekBeginTime = 0;\n\n        if (seconds < 1.0 && this._mediaElement.buffered.length > 0) {\n            let videoBeginTime = this._mediaElement.buffered.start(0);\n            if ((videoBeginTime < 1.0 && seconds < videoBeginTime) || Browser.safari) {\n                directSeekBegin = true;\n                // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n                directSeekBeginTime = Browser.safari ? 0.1 : videoBeginTime;\n            }\n        }\n\n        if (directSeekBegin) {  // seek to video begin, set currentTime directly if beginPTS buffered\n            this._requestSetTime = true;\n            this._mediaElement.currentTime = directSeekBeginTime;\n        }  else if (directSeek) {  // buffered position\n            if (!this._alwaysSeekKeyframe) {\n                this._requestSetTime = true;\n                this._mediaElement.currentTime = seconds;\n            } else {\n                let idr = this._msectl.getNearestKeyframe(Math.floor(seconds * 1000));\n                this._requestSetTime = true;\n                if (idr != null) {\n                    this._mediaElement.currentTime = idr.dts / 1000;\n                } else {\n                    this._mediaElement.currentTime = seconds;\n                }\n            }\n            if (this._progressChecker != null) {\n                this._checkProgressAndResume();\n            }\n        } else {\n            if (this._progressChecker != null) {\n                window.clearInterval(this._progressChecker);\n                this._progressChecker = null;\n            }\n            this._msectl.seek(seconds);\n            this._transmuxer.seek(Math.floor(seconds * 1000));  // in milliseconds\n            // no need to set mediaElement.currentTime if non-accurateSeek,\n            // just wait for the recommend_seekpoint callback\n            if (this._config.accurateSeek) {\n                this._requestSetTime = true;\n                this._mediaElement.currentTime = seconds;\n            }\n        }\n    }\n\n    _checkAndApplyUnbufferedSeekpoint() {\n        if (this._seekpointRecord) {\n            if (this._seekpointRecord.recordTime <= this._now() - 100) {\n                let target = this._mediaElement.currentTime;\n                this._seekpointRecord = null;\n                if (!this._isTimepointBuffered(target)) {\n                    if (this._progressChecker != null) {\n                        window.clearTimeout(this._progressChecker);\n                        this._progressChecker = null;\n                    }\n                    // .currentTime is consists with .buffered timestamp\n                    // Chrome/Edge use DTS, while FireFox/Safari use PTS\n                    this._msectl.seek(target);\n                    this._transmuxer.seek(Math.floor(target * 1000));\n                    // set currentTime if accurateSeek, or wait for recommend_seekpoint callback\n                    if (this._config.accurateSeek) {\n                        this._requestSetTime = true;\n                        this._mediaElement.currentTime = target;\n                    }\n                }\n            } else {\n                window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n            }\n        }\n    }\n\n    _checkAndResumeStuckPlayback(stalled) {\n        let media = this._mediaElement;\n        if (stalled || !this._receivedCanPlay || media.readyState < 2) {  // HAVE_CURRENT_DATA\n            let buffered = media.buffered;\n            if (buffered.length > 0 && media.currentTime < buffered.start(0)) {\n                Log.w(this.TAG, `Playback seems stuck at ${media.currentTime}, seek to ${buffered.start(0)}`);\n                this._requestSetTime = true;\n                this._mediaElement.currentTime = buffered.start(0);\n                this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n            }\n        } else {\n            // Playback didn't stuck, remove progress event listener\n            this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n        }\n    }\n\n    _onvLoadedMetadata(e) {\n        if (this._pendingSeekTime != null) {\n            this._mediaElement.currentTime = this._pendingSeekTime;\n            this._pendingSeekTime = null;\n        }\n    }\n\n    _onvSeeking(e) {  // handle seeking request from browser's progress bar\n        let target = this._mediaElement.currentTime;\n        let buffered = this._mediaElement.buffered;\n\n        if (this._requestSetTime) {\n            this._requestSetTime = false;\n            return;\n        }\n\n        if (target < 1.0 && buffered.length > 0) {\n            // seek to video begin, set currentTime directly if beginPTS buffered\n            let videoBeginTime = buffered.start(0);\n            if ((videoBeginTime < 1.0 && target < videoBeginTime) || Browser.safari) {\n                this._requestSetTime = true;\n                // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n                this._mediaElement.currentTime = Browser.safari ? 0.1 : videoBeginTime;\n                return;\n            }\n        }\n\n        if (this._isTimepointBuffered(target)) {\n            if (this._alwaysSeekKeyframe) {\n                let idr = this._msectl.getNearestKeyframe(Math.floor(target * 1000));\n                if (idr != null) {\n                    this._requestSetTime = true;\n                    this._mediaElement.currentTime = idr.dts / 1000;\n                }\n            }\n            if (this._progressChecker != null) {\n                this._checkProgressAndResume();\n            }\n            return;\n        }\n\n        this._seekpointRecord = {\n            seekPoint: target,\n            recordTime: this._now()\n        };\n        window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n    }\n\n    _onvCanPlay(e) {\n        this._receivedCanPlay = true;\n        this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n    }\n\n    _onvStalled(e) {\n        this._checkAndResumeStuckPlayback(true);\n    }\n\n    _onvProgress(e) {\n        this._checkAndResumeStuckPlayback();\n    }\n\n}\n\nexport default FlvPlayer;"]},"metadata":{},"sourceType":"module"}