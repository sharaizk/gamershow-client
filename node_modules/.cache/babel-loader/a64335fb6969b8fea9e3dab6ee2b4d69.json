{"ast":null,"code":"import _classCallCheck from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport { LoaderStatus, LoaderErrors } from './loader.js';\nimport FetchStreamLoader from './fetch-stream-loader.js';\nimport MozChunkedLoader from './xhr-moz-chunked-loader.js';\nimport MSStreamLoader from './xhr-msstream-loader.js';\nimport RangeLoader from './xhr-range-loader.js';\nimport WebSocketLoader from './websocket-loader.js';\nimport RangeSeekHandler from './range-seek-handler.js';\nimport ParamSeekHandler from './param-seek-handler.js';\nimport { RuntimeException, IllegalStateException, InvalidArgumentException } from '../utils/exception.js';\n/**\n * DataSource: {\n *     url: string,\n *     filesize: number,\n *     cors: boolean,\n *     withCredentials: boolean\n * }\n * \n */\n// Manage IO Loaders\n\nvar IOController = /*#__PURE__*/function () {\n  function IOController(dataSource, config, extraData) {\n    _classCallCheck(this, IOController);\n\n    this.TAG = 'IOController';\n    this._config = config;\n    this._extraData = extraData;\n    this._stashInitialSize = 1024 * 384; // default initial size: 384KB\n\n    if (config.stashInitialSize != undefined && config.stashInitialSize > 0) {\n      // apply from config\n      this._stashInitialSize = config.stashInitialSize;\n    }\n\n    this._stashUsed = 0;\n    this._stashSize = this._stashInitialSize;\n    this._bufferSize = 1024 * 1024 * 3; // initial size: 3MB\n\n    this._stashBuffer = new ArrayBuffer(this._bufferSize);\n    this._stashByteStart = 0;\n    this._enableStash = true;\n\n    if (config.enableStashBuffer === false) {\n      this._enableStash = false;\n    }\n\n    this._loader = null;\n    this._loaderClass = null;\n    this._seekHandler = null;\n    this._dataSource = dataSource;\n    this._isWebSocketURL = /wss?:\\/\\/(.+?)/.test(dataSource.url);\n    this._refTotalLength = dataSource.filesize ? dataSource.filesize : null;\n    this._totalLength = this._refTotalLength;\n    this._fullRequestFlag = false;\n    this._currentRange = null;\n    this._redirectedURL = null;\n    this._speedNormalized = 0;\n    this._speedSampler = new SpeedSampler();\n    this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096];\n    this._isEarlyEofReconnecting = false;\n    this._paused = false;\n    this._resumeFrom = 0;\n    this._onDataArrival = null;\n    this._onSeeked = null;\n    this._onError = null;\n    this._onComplete = null;\n    this._onRedirect = null;\n    this._onRecoveredEarlyEof = null;\n\n    this._selectSeekHandler();\n\n    this._selectLoader();\n\n    this._createLoader();\n  }\n\n  _createClass(IOController, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._loader.isWorking()) {\n        this._loader.abort();\n      }\n\n      this._loader.destroy();\n\n      this._loader = null;\n      this._loaderClass = null;\n      this._dataSource = null;\n      this._stashBuffer = null;\n      this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0;\n      this._currentRange = null;\n      this._speedSampler = null;\n      this._isEarlyEofReconnecting = false;\n      this._onDataArrival = null;\n      this._onSeeked = null;\n      this._onError = null;\n      this._onComplete = null;\n      this._onRedirect = null;\n      this._onRecoveredEarlyEof = null;\n      this._extraData = null;\n    }\n  }, {\n    key: \"isWorking\",\n    value: function isWorking() {\n      return this._loader && this._loader.isWorking() && !this._paused;\n    }\n  }, {\n    key: \"isPaused\",\n    value: function isPaused() {\n      return this._paused;\n    }\n  }, {\n    key: \"status\",\n    get: function get() {\n      return this._loader.status;\n    }\n  }, {\n    key: \"extraData\",\n    get: function get() {\n      return this._extraData;\n    },\n    set: function set(data) {\n      this._extraData = data;\n    } // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number\n\n  }, {\n    key: \"onDataArrival\",\n    get: function get() {\n      return this._onDataArrival;\n    },\n    set: function set(callback) {\n      this._onDataArrival = callback;\n    }\n  }, {\n    key: \"onSeeked\",\n    get: function get() {\n      return this._onSeeked;\n    },\n    set: function set(callback) {\n      this._onSeeked = callback;\n    } // prototype: function onError(type: number, info: {code: number, msg: string}): void\n\n  }, {\n    key: \"onError\",\n    get: function get() {\n      return this._onError;\n    },\n    set: function set(callback) {\n      this._onError = callback;\n    }\n  }, {\n    key: \"onComplete\",\n    get: function get() {\n      return this._onComplete;\n    },\n    set: function set(callback) {\n      this._onComplete = callback;\n    }\n  }, {\n    key: \"onRedirect\",\n    get: function get() {\n      return this._onRedirect;\n    },\n    set: function set(callback) {\n      this._onRedirect = callback;\n    }\n  }, {\n    key: \"onRecoveredEarlyEof\",\n    get: function get() {\n      return this._onRecoveredEarlyEof;\n    },\n    set: function set(callback) {\n      this._onRecoveredEarlyEof = callback;\n    }\n  }, {\n    key: \"currentURL\",\n    get: function get() {\n      return this._dataSource.url;\n    }\n  }, {\n    key: \"hasRedirect\",\n    get: function get() {\n      return this._redirectedURL != null || this._dataSource.redirectedURL != undefined;\n    }\n  }, {\n    key: \"currentRedirectedURL\",\n    get: function get() {\n      return this._redirectedURL || this._dataSource.redirectedURL;\n    } // in KB/s\n\n  }, {\n    key: \"currentSpeed\",\n    get: function get() {\n      if (this._loaderClass === RangeLoader) {\n        // SpeedSampler is inaccuracy if loader is RangeLoader\n        return this._loader.currentSpeed;\n      }\n\n      return this._speedSampler.lastSecondKBps;\n    }\n  }, {\n    key: \"loaderType\",\n    get: function get() {\n      return this._loader.type;\n    }\n  }, {\n    key: \"_selectSeekHandler\",\n    value: function _selectSeekHandler() {\n      var config = this._config;\n\n      if (config.seekType === 'range') {\n        this._seekHandler = new RangeSeekHandler(this._config.rangeLoadZeroStart);\n      } else if (config.seekType === 'param') {\n        var paramStart = config.seekParamStart || 'bstart';\n        var paramEnd = config.seekParamEnd || 'bend';\n        this._seekHandler = new ParamSeekHandler(paramStart, paramEnd);\n      } else if (config.seekType === 'custom') {\n        if (typeof config.customSeekHandler !== 'function') {\n          throw new InvalidArgumentException('Custom seekType specified in config but invalid customSeekHandler!');\n        }\n\n        this._seekHandler = new config.customSeekHandler();\n      } else {\n        throw new InvalidArgumentException(\"Invalid seekType in config: \".concat(config.seekType));\n      }\n    }\n  }, {\n    key: \"_selectLoader\",\n    value: function _selectLoader() {\n      if (this._config.customLoader != null) {\n        this._loaderClass = this._config.customLoader;\n      } else if (this._isWebSocketURL) {\n        this._loaderClass = WebSocketLoader;\n      } else if (FetchStreamLoader.isSupported()) {\n        this._loaderClass = FetchStreamLoader;\n      } else if (MozChunkedLoader.isSupported()) {\n        this._loaderClass = MozChunkedLoader;\n      } else if (RangeLoader.isSupported()) {\n        this._loaderClass = RangeLoader;\n      } else {\n        throw new RuntimeException('Your browser doesn\\'t support xhr with arraybuffer responseType!');\n      }\n    }\n  }, {\n    key: \"_createLoader\",\n    value: function _createLoader() {\n      this._loader = new this._loaderClass(this._seekHandler, this._config);\n\n      if (this._loader.needStashBuffer === false) {\n        this._enableStash = false;\n      }\n\n      this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this);\n      this._loader.onURLRedirect = this._onURLRedirect.bind(this);\n      this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this);\n      this._loader.onComplete = this._onLoaderComplete.bind(this);\n      this._loader.onError = this._onLoaderError.bind(this);\n    }\n  }, {\n    key: \"open\",\n    value: function open(optionalFrom) {\n      this._currentRange = {\n        from: 0,\n        to: -1\n      };\n\n      if (optionalFrom) {\n        this._currentRange.from = optionalFrom;\n      }\n\n      this._speedSampler.reset();\n\n      if (!optionalFrom) {\n        this._fullRequestFlag = true;\n      }\n\n      this._loader.open(this._dataSource, Object.assign({}, this._currentRange));\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._loader.abort();\n\n      if (this._paused) {\n        this._paused = false;\n        this._resumeFrom = 0;\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.isWorking()) {\n        this._loader.abort();\n\n        if (this._stashUsed !== 0) {\n          this._resumeFrom = this._stashByteStart;\n          this._currentRange.to = this._stashByteStart - 1;\n        } else {\n          this._resumeFrom = this._currentRange.to + 1;\n        }\n\n        this._stashUsed = 0;\n        this._stashByteStart = 0;\n        this._paused = true;\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._paused) {\n        this._paused = false;\n        var bytes = this._resumeFrom;\n        this._resumeFrom = 0;\n\n        this._internalSeek(bytes, true);\n      }\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(bytes) {\n      this._paused = false;\n      this._stashUsed = 0;\n      this._stashByteStart = 0;\n\n      this._internalSeek(bytes, true);\n    }\n    /**\n     * When seeking request is from media seeking, unconsumed stash data should be dropped\n     * However, stash data shouldn't be dropped if seeking requested from http reconnection\n     *\n     * @dropUnconsumed: Ignore and discard all unconsumed data in stash buffer\n     */\n\n  }, {\n    key: \"_internalSeek\",\n    value: function _internalSeek(bytes, dropUnconsumed) {\n      if (this._loader.isWorking()) {\n        this._loader.abort();\n      } // dispatch & flush stash buffer before seek\n\n\n      this._flushStashBuffer(dropUnconsumed);\n\n      this._loader.destroy();\n\n      this._loader = null;\n      var requestRange = {\n        from: bytes,\n        to: -1\n      };\n      this._currentRange = {\n        from: requestRange.from,\n        to: -1\n      };\n\n      this._speedSampler.reset();\n\n      this._stashSize = this._stashInitialSize;\n\n      this._createLoader();\n\n      this._loader.open(this._dataSource, requestRange);\n\n      if (this._onSeeked) {\n        this._onSeeked();\n      }\n    }\n  }, {\n    key: \"updateUrl\",\n    value: function updateUrl(url) {\n      if (!url || typeof url !== 'string' || url.length === 0) {\n        throw new InvalidArgumentException('Url must be a non-empty string!');\n      }\n\n      this._dataSource.url = url; // TODO: replace with new url\n    }\n  }, {\n    key: \"_expandBuffer\",\n    value: function _expandBuffer(expectedBytes) {\n      var bufferNewSize = this._stashSize;\n\n      while (bufferNewSize + 1024 * 1024 * 1 < expectedBytes) {\n        bufferNewSize *= 2;\n      }\n\n      bufferNewSize += 1024 * 1024 * 1; // bufferSize = stashSize + 1MB\n\n      if (bufferNewSize === this._bufferSize) {\n        return;\n      }\n\n      var newBuffer = new ArrayBuffer(bufferNewSize);\n\n      if (this._stashUsed > 0) {\n        // copy existing data into new buffer\n        var stashOldArray = new Uint8Array(this._stashBuffer, 0, this._stashUsed);\n        var stashNewArray = new Uint8Array(newBuffer, 0, bufferNewSize);\n        stashNewArray.set(stashOldArray, 0);\n      }\n\n      this._stashBuffer = newBuffer;\n      this._bufferSize = bufferNewSize;\n    }\n  }, {\n    key: \"_normalizeSpeed\",\n    value: function _normalizeSpeed(input) {\n      var list = this._speedNormalizeList;\n      var last = list.length - 1;\n      var mid = 0;\n      var lbound = 0;\n      var ubound = last;\n\n      if (input < list[0]) {\n        return list[0];\n      } // binary search\n\n\n      while (lbound <= ubound) {\n        mid = lbound + Math.floor((ubound - lbound) / 2);\n\n        if (mid === last || input >= list[mid] && input < list[mid + 1]) {\n          return list[mid];\n        } else if (list[mid] < input) {\n          lbound = mid + 1;\n        } else {\n          ubound = mid - 1;\n        }\n      }\n    }\n  }, {\n    key: \"_adjustStashSize\",\n    value: function _adjustStashSize(normalized) {\n      var stashSizeKB = 0;\n\n      if (this._config.isLive) {\n        // live stream: always use single normalized speed for size of stashSizeKB\n        stashSizeKB = normalized;\n      } else {\n        if (normalized < 512) {\n          stashSizeKB = normalized;\n        } else if (normalized >= 512 && normalized <= 1024) {\n          stashSizeKB = Math.floor(normalized * 1.5);\n        } else {\n          stashSizeKB = normalized * 2;\n        }\n      }\n\n      if (stashSizeKB > 8192) {\n        stashSizeKB = 8192;\n      }\n\n      var bufferSize = stashSizeKB * 1024 + 1024 * 1024 * 1; // stashSize + 1MB\n\n      if (this._bufferSize < bufferSize) {\n        this._expandBuffer(bufferSize);\n      }\n\n      this._stashSize = stashSizeKB * 1024;\n    }\n  }, {\n    key: \"_dispatchChunks\",\n    value: function _dispatchChunks(chunks, byteStart) {\n      this._currentRange.to = byteStart + chunks.byteLength - 1;\n      return this._onDataArrival(chunks, byteStart);\n    }\n  }, {\n    key: \"_onURLRedirect\",\n    value: function _onURLRedirect(redirectedURL) {\n      this._redirectedURL = redirectedURL;\n\n      if (this._onRedirect) {\n        this._onRedirect(redirectedURL);\n      }\n    }\n  }, {\n    key: \"_onContentLengthKnown\",\n    value: function _onContentLengthKnown(contentLength) {\n      if (contentLength && this._fullRequestFlag) {\n        this._totalLength = contentLength;\n        this._fullRequestFlag = false;\n      }\n    }\n  }, {\n    key: \"_onLoaderChunkArrival\",\n    value: function _onLoaderChunkArrival(chunk, byteStart, receivedLength) {\n      if (!this._onDataArrival) {\n        throw new IllegalStateException('IOController: No existing consumer (onDataArrival) callback!');\n      }\n\n      if (this._paused) {\n        return;\n      }\n\n      if (this._isEarlyEofReconnecting) {\n        // Auto-reconnect for EarlyEof succeed, notify to upper-layer by callback\n        this._isEarlyEofReconnecting = false;\n\n        if (this._onRecoveredEarlyEof) {\n          this._onRecoveredEarlyEof();\n        }\n      }\n\n      this._speedSampler.addBytes(chunk.byteLength); // adjust stash buffer size according to network speed dynamically\n\n\n      var KBps = this._speedSampler.lastSecondKBps;\n\n      if (KBps !== 0) {\n        var normalized = this._normalizeSpeed(KBps);\n\n        if (this._speedNormalized !== normalized) {\n          this._speedNormalized = normalized;\n\n          this._adjustStashSize(normalized);\n        }\n      }\n\n      if (!this._enableStash) {\n        // disable stash\n        if (this._stashUsed === 0) {\n          // dispatch chunk directly to consumer;\n          // check ret value (consumed bytes) and stash unconsumed to stashBuffer\n          var consumed = this._dispatchChunks(chunk, byteStart);\n\n          if (consumed < chunk.byteLength) {\n            // unconsumed data remain.\n            var remain = chunk.byteLength - consumed;\n\n            if (remain > this._bufferSize) {\n              this._expandBuffer(remain);\n            }\n\n            var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            stashArray.set(new Uint8Array(chunk, consumed), 0);\n            this._stashUsed += remain;\n            this._stashByteStart = byteStart + consumed;\n          }\n        } else {\n          // else: Merge chunk into stashBuffer, and dispatch stashBuffer to consumer.\n          if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n            this._expandBuffer(this._stashUsed + chunk.byteLength);\n          }\n\n          var _stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n\n          _stashArray.set(new Uint8Array(chunk), this._stashUsed);\n\n          this._stashUsed += chunk.byteLength;\n\n          var _consumed = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);\n\n          if (_consumed < this._stashUsed && _consumed > 0) {\n            // unconsumed data remain\n            var remainArray = new Uint8Array(this._stashBuffer, _consumed);\n\n            _stashArray.set(remainArray, 0);\n          }\n\n          this._stashUsed -= _consumed;\n          this._stashByteStart += _consumed;\n        }\n      } else {\n        // enable stash\n        if (this._stashUsed === 0 && this._stashByteStart === 0) {\n          // seeked? or init chunk?\n          // This is the first chunk after seek action\n          this._stashByteStart = byteStart;\n        }\n\n        if (this._stashUsed + chunk.byteLength <= this._stashSize) {\n          // just stash\n          var _stashArray2 = new Uint8Array(this._stashBuffer, 0, this._stashSize);\n\n          _stashArray2.set(new Uint8Array(chunk), this._stashUsed);\n\n          this._stashUsed += chunk.byteLength;\n        } else {\n          // stashUsed + chunkSize > stashSize, size limit exceeded\n          var _stashArray3 = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n\n          if (this._stashUsed > 0) {\n            // There're stash datas in buffer\n            // dispatch the whole stashBuffer, and stash remain data\n            // then append chunk to stashBuffer (stash)\n            var buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n            var _consumed2 = this._dispatchChunks(buffer, this._stashByteStart);\n\n            if (_consumed2 < buffer.byteLength) {\n              if (_consumed2 > 0) {\n                var _remainArray = new Uint8Array(buffer, _consumed2);\n\n                _stashArray3.set(_remainArray, 0);\n\n                this._stashUsed = _remainArray.byteLength;\n                this._stashByteStart += _consumed2;\n              }\n            } else {\n              this._stashUsed = 0;\n              this._stashByteStart += _consumed2;\n            }\n\n            if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n              this._expandBuffer(this._stashUsed + chunk.byteLength);\n\n              _stashArray3 = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            }\n\n            _stashArray3.set(new Uint8Array(chunk), this._stashUsed);\n\n            this._stashUsed += chunk.byteLength;\n          } else {\n            // stash buffer empty, but chunkSize > stashSize (oh, holy shit)\n            // dispatch chunk directly and stash remain data\n            var _consumed3 = this._dispatchChunks(chunk, byteStart);\n\n            if (_consumed3 < chunk.byteLength) {\n              var _remain = chunk.byteLength - _consumed3;\n\n              if (_remain > this._bufferSize) {\n                this._expandBuffer(_remain);\n\n                _stashArray3 = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n              }\n\n              _stashArray3.set(new Uint8Array(chunk, _consumed3), 0);\n\n              this._stashUsed += _remain;\n              this._stashByteStart = byteStart + _consumed3;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_flushStashBuffer\",\n    value: function _flushStashBuffer(dropUnconsumed) {\n      if (this._stashUsed > 0) {\n        var buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n        var consumed = this._dispatchChunks(buffer, this._stashByteStart);\n\n        var remain = buffer.byteLength - consumed;\n\n        if (consumed < buffer.byteLength) {\n          if (dropUnconsumed) {\n            Log.w(this.TAG, \"\".concat(remain, \" bytes unconsumed data remain when flush buffer, dropped\"));\n          } else {\n            if (consumed > 0) {\n              var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n              var remainArray = new Uint8Array(buffer, consumed);\n              stashArray.set(remainArray, 0);\n              this._stashUsed = remainArray.byteLength;\n              this._stashByteStart += consumed;\n            }\n\n            return 0;\n          }\n        }\n\n        this._stashUsed = 0;\n        this._stashByteStart = 0;\n        return remain;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_onLoaderComplete\",\n    value: function _onLoaderComplete(from, to) {\n      // Force-flush stash buffer, and drop unconsumed data\n      this._flushStashBuffer(true);\n\n      if (this._onComplete) {\n        this._onComplete(this._extraData);\n      }\n    }\n  }, {\n    key: \"_onLoaderError\",\n    value: function _onLoaderError(type, data) {\n      Log.e(this.TAG, \"Loader error, code = \".concat(data.code, \", msg = \").concat(data.msg));\n\n      this._flushStashBuffer(false);\n\n      if (this._isEarlyEofReconnecting) {\n        // Auto-reconnect for EarlyEof failed, throw UnrecoverableEarlyEof error to upper-layer\n        this._isEarlyEofReconnecting = false;\n        type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n      }\n\n      switch (type) {\n        case LoaderErrors.EARLY_EOF:\n          {\n            if (!this._config.isLive) {\n              // Do internal http reconnect if not live stream\n              if (this._totalLength) {\n                var nextFrom = this._currentRange.to + 1;\n\n                if (nextFrom < this._totalLength) {\n                  Log.w(this.TAG, 'Connection lost, trying reconnect...');\n                  this._isEarlyEofReconnecting = true;\n\n                  this._internalSeek(nextFrom, false);\n                }\n\n                return;\n              } // else: We don't know totalLength, throw UnrecoverableEarlyEof\n\n            } // live stream: throw UnrecoverableEarlyEof error to upper-layer\n\n\n            type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n            break;\n          }\n\n        case LoaderErrors.UNRECOVERABLE_EARLY_EOF:\n        case LoaderErrors.CONNECTING_TIMEOUT:\n        case LoaderErrors.HTTP_STATUS_CODE_INVALID:\n        case LoaderErrors.EXCEPTION:\n          break;\n      }\n\n      if (this._onError) {\n        this._onError(type, data);\n      } else {\n        throw new RuntimeException('IOException: ' + data.msg);\n      }\n    }\n  }]);\n\n  return IOController;\n}();\n\nexport default IOController;","map":{"version":3,"sources":["D:/STREAMING_SITE/client/node_modules/flv.js/src/io/io-controller.js"],"names":["Log","SpeedSampler","LoaderStatus","LoaderErrors","FetchStreamLoader","MozChunkedLoader","MSStreamLoader","RangeLoader","WebSocketLoader","RangeSeekHandler","ParamSeekHandler","RuntimeException","IllegalStateException","InvalidArgumentException","IOController","dataSource","config","extraData","TAG","_config","_extraData","_stashInitialSize","stashInitialSize","undefined","_stashUsed","_stashSize","_bufferSize","_stashBuffer","ArrayBuffer","_stashByteStart","_enableStash","enableStashBuffer","_loader","_loaderClass","_seekHandler","_dataSource","_isWebSocketURL","test","url","_refTotalLength","filesize","_totalLength","_fullRequestFlag","_currentRange","_redirectedURL","_speedNormalized","_speedSampler","_speedNormalizeList","_isEarlyEofReconnecting","_paused","_resumeFrom","_onDataArrival","_onSeeked","_onError","_onComplete","_onRedirect","_onRecoveredEarlyEof","_selectSeekHandler","_selectLoader","_createLoader","isWorking","abort","destroy","status","data","callback","redirectedURL","currentSpeed","lastSecondKBps","type","seekType","rangeLoadZeroStart","paramStart","seekParamStart","paramEnd","seekParamEnd","customSeekHandler","customLoader","isSupported","needStashBuffer","onContentLengthKnown","_onContentLengthKnown","bind","onURLRedirect","_onURLRedirect","onDataArrival","_onLoaderChunkArrival","onComplete","_onLoaderComplete","onError","_onLoaderError","optionalFrom","from","to","reset","open","Object","assign","bytes","_internalSeek","dropUnconsumed","_flushStashBuffer","requestRange","length","expectedBytes","bufferNewSize","newBuffer","stashOldArray","Uint8Array","stashNewArray","set","input","list","last","mid","lbound","ubound","Math","floor","normalized","stashSizeKB","isLive","bufferSize","_expandBuffer","chunks","byteStart","byteLength","contentLength","chunk","receivedLength","addBytes","KBps","_normalizeSpeed","_adjustStashSize","consumed","_dispatchChunks","remain","stashArray","slice","remainArray","buffer","w","e","code","msg","UNRECOVERABLE_EARLY_EOF","EARLY_EOF","nextFrom","CONNECTING_TIMEOUT","HTTP_STATUS_CODE_INVALID","EXCEPTION"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport {LoaderStatus, LoaderErrors} from './loader.js';\nimport FetchStreamLoader from './fetch-stream-loader.js';\nimport MozChunkedLoader from './xhr-moz-chunked-loader.js';\nimport MSStreamLoader from './xhr-msstream-loader.js';\nimport RangeLoader from './xhr-range-loader.js';\nimport WebSocketLoader from './websocket-loader.js';\nimport RangeSeekHandler from './range-seek-handler.js';\nimport ParamSeekHandler from './param-seek-handler.js';\nimport {RuntimeException, IllegalStateException, InvalidArgumentException} from '../utils/exception.js';\n\n/**\n * DataSource: {\n *     url: string,\n *     filesize: number,\n *     cors: boolean,\n *     withCredentials: boolean\n * }\n * \n */\n\n// Manage IO Loaders\nclass IOController {\n\n    constructor(dataSource, config, extraData) {\n        this.TAG = 'IOController';\n\n        this._config = config;\n        this._extraData = extraData;\n\n        this._stashInitialSize = 1024 * 384;  // default initial size: 384KB\n        if (config.stashInitialSize != undefined && config.stashInitialSize > 0) {\n            // apply from config\n            this._stashInitialSize = config.stashInitialSize;\n        }\n\n        this._stashUsed = 0;\n        this._stashSize = this._stashInitialSize;\n        this._bufferSize = 1024 * 1024 * 3;  // initial size: 3MB\n        this._stashBuffer = new ArrayBuffer(this._bufferSize);\n        this._stashByteStart = 0;\n        this._enableStash = true;\n        if (config.enableStashBuffer === false) {\n            this._enableStash = false;\n        }\n\n        this._loader = null;\n        this._loaderClass = null;\n        this._seekHandler = null;\n\n        this._dataSource = dataSource;\n        this._isWebSocketURL = /wss?:\\/\\/(.+?)/.test(dataSource.url);\n        this._refTotalLength = dataSource.filesize ? dataSource.filesize : null;\n        this._totalLength = this._refTotalLength;\n        this._fullRequestFlag = false;\n        this._currentRange = null;\n        this._redirectedURL = null;\n\n        this._speedNormalized = 0;\n        this._speedSampler = new SpeedSampler();\n        this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096];\n\n        this._isEarlyEofReconnecting = false;\n\n        this._paused = false;\n        this._resumeFrom = 0;\n\n        this._onDataArrival = null;\n        this._onSeeked = null;\n        this._onError = null;\n        this._onComplete = null;\n        this._onRedirect = null;\n        this._onRecoveredEarlyEof = null;\n\n        this._selectSeekHandler();\n        this._selectLoader();\n        this._createLoader();\n    }\n\n    destroy() {\n        if (this._loader.isWorking()) {\n            this._loader.abort();\n        }\n        this._loader.destroy();\n        this._loader = null;\n        this._loaderClass = null;\n        this._dataSource = null;\n        this._stashBuffer = null;\n        this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0;\n        this._currentRange = null;\n        this._speedSampler = null;\n\n        this._isEarlyEofReconnecting = false;\n\n        this._onDataArrival = null;\n        this._onSeeked = null;\n        this._onError = null;\n        this._onComplete = null;\n        this._onRedirect = null;\n        this._onRecoveredEarlyEof = null;\n\n        this._extraData = null;\n    }\n\n    isWorking() {\n        return this._loader && this._loader.isWorking() && !this._paused;\n    }\n\n    isPaused() {\n        return this._paused;\n    }\n\n    get status() {\n        return this._loader.status;\n    }\n\n    get extraData() {\n        return this._extraData;\n    }\n\n    set extraData(data) {\n        this._extraData = data;\n    }\n\n    // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number\n    get onDataArrival() {\n        return this._onDataArrival;\n    }\n\n    set onDataArrival(callback) {\n        this._onDataArrival = callback;\n    }\n\n    get onSeeked() {\n        return this._onSeeked;\n    }\n\n    set onSeeked(callback) {\n        this._onSeeked = callback;\n    }\n\n    // prototype: function onError(type: number, info: {code: number, msg: string}): void\n    get onError() {\n        return this._onError;\n    }\n\n    set onError(callback) {\n        this._onError = callback;\n    }\n\n    get onComplete() {\n        return this._onComplete;\n    }\n\n    set onComplete(callback) {\n        this._onComplete = callback;\n    }\n\n    get onRedirect() {\n        return this._onRedirect;\n    }\n\n    set onRedirect(callback) {\n        this._onRedirect = callback;\n    }\n\n    get onRecoveredEarlyEof() {\n        return this._onRecoveredEarlyEof;\n    }\n\n    set onRecoveredEarlyEof(callback) {\n        this._onRecoveredEarlyEof = callback;\n    }\n\n    get currentURL() {\n        return this._dataSource.url;\n    }\n\n    get hasRedirect() {\n        return (this._redirectedURL != null || this._dataSource.redirectedURL != undefined);\n    }\n\n    get currentRedirectedURL() {\n        return this._redirectedURL || this._dataSource.redirectedURL;\n    }\n\n    // in KB/s\n    get currentSpeed() {\n        if (this._loaderClass === RangeLoader) {\n            // SpeedSampler is inaccuracy if loader is RangeLoader\n            return this._loader.currentSpeed;\n        }\n        return this._speedSampler.lastSecondKBps;\n    }\n\n    get loaderType() {\n        return this._loader.type;\n    }\n\n    _selectSeekHandler() {\n        let config = this._config;\n\n        if (config.seekType === 'range') {\n            this._seekHandler = new RangeSeekHandler(this._config.rangeLoadZeroStart);\n        } else if (config.seekType === 'param') {\n            let paramStart = config.seekParamStart || 'bstart';\n            let paramEnd = config.seekParamEnd || 'bend';\n\n            this._seekHandler = new ParamSeekHandler(paramStart, paramEnd);\n        } else if (config.seekType === 'custom') {\n            if (typeof config.customSeekHandler !== 'function') {\n                throw new InvalidArgumentException('Custom seekType specified in config but invalid customSeekHandler!');\n            }\n            this._seekHandler = new config.customSeekHandler();\n        } else {\n            throw new InvalidArgumentException(`Invalid seekType in config: ${config.seekType}`);\n        }\n    }\n\n    _selectLoader() {\n        if (this._config.customLoader != null) {\n            this._loaderClass = this._config.customLoader;\n        } else if (this._isWebSocketURL) {\n            this._loaderClass = WebSocketLoader;\n        } else if (FetchStreamLoader.isSupported()) {\n            this._loaderClass = FetchStreamLoader;\n        } else if (MozChunkedLoader.isSupported()) {\n            this._loaderClass = MozChunkedLoader;\n        } else if (RangeLoader.isSupported()) {\n            this._loaderClass = RangeLoader;\n        } else {\n            throw new RuntimeException('Your browser doesn\\'t support xhr with arraybuffer responseType!');\n        }\n    }\n\n    _createLoader() {\n        this._loader = new this._loaderClass(this._seekHandler, this._config);\n        if (this._loader.needStashBuffer === false) {\n            this._enableStash = false;\n        }\n        this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this);\n        this._loader.onURLRedirect = this._onURLRedirect.bind(this);\n        this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this);\n        this._loader.onComplete = this._onLoaderComplete.bind(this);\n        this._loader.onError = this._onLoaderError.bind(this);\n    }\n\n    open(optionalFrom) {\n        this._currentRange = {from: 0, to: -1};\n        if (optionalFrom) {\n            this._currentRange.from = optionalFrom;\n        }\n\n        this._speedSampler.reset();\n        if (!optionalFrom) {\n            this._fullRequestFlag = true;\n        }\n\n        this._loader.open(this._dataSource, Object.assign({}, this._currentRange));\n    }\n\n    abort() {\n        this._loader.abort();\n\n        if (this._paused) {\n            this._paused = false;\n            this._resumeFrom = 0;\n        }\n    }\n\n    pause() {\n        if (this.isWorking()) {\n            this._loader.abort();\n\n            if (this._stashUsed !== 0) {\n                this._resumeFrom = this._stashByteStart;\n                this._currentRange.to = this._stashByteStart - 1;\n            } else {\n                this._resumeFrom = this._currentRange.to + 1;\n            }\n            this._stashUsed = 0;\n            this._stashByteStart = 0;\n            this._paused = true;\n        }\n    }\n\n    resume() {\n        if (this._paused) {\n            this._paused = false;\n            let bytes = this._resumeFrom;\n            this._resumeFrom = 0;\n            this._internalSeek(bytes, true);\n        }\n    }\n\n    seek(bytes) {\n        this._paused = false;\n        this._stashUsed = 0;\n        this._stashByteStart = 0;\n        this._internalSeek(bytes, true);\n    }\n\n    /**\n     * When seeking request is from media seeking, unconsumed stash data should be dropped\n     * However, stash data shouldn't be dropped if seeking requested from http reconnection\n     *\n     * @dropUnconsumed: Ignore and discard all unconsumed data in stash buffer\n     */\n    _internalSeek(bytes, dropUnconsumed) {\n        if (this._loader.isWorking()) {\n            this._loader.abort();\n        }\n\n        // dispatch & flush stash buffer before seek\n        this._flushStashBuffer(dropUnconsumed);\n\n        this._loader.destroy();\n        this._loader = null;\n\n        let requestRange = {from: bytes, to: -1};\n        this._currentRange = {from: requestRange.from, to: -1};\n\n        this._speedSampler.reset();\n        this._stashSize = this._stashInitialSize;\n        this._createLoader();\n        this._loader.open(this._dataSource, requestRange);\n\n        if (this._onSeeked) {\n            this._onSeeked();\n        }\n    }\n\n    updateUrl(url) {\n        if (!url || typeof url !== 'string' || url.length === 0) {\n            throw new InvalidArgumentException('Url must be a non-empty string!');\n        }\n\n        this._dataSource.url = url;\n\n        // TODO: replace with new url\n    }\n\n    _expandBuffer(expectedBytes) {\n        let bufferNewSize = this._stashSize;\n        while (bufferNewSize + 1024 * 1024 * 1 < expectedBytes) {\n            bufferNewSize *= 2;\n        }\n\n        bufferNewSize += 1024 * 1024 * 1;  // bufferSize = stashSize + 1MB\n        if (bufferNewSize === this._bufferSize) {\n            return;\n        }\n\n        let newBuffer = new ArrayBuffer(bufferNewSize);\n\n        if (this._stashUsed > 0) {  // copy existing data into new buffer\n            let stashOldArray = new Uint8Array(this._stashBuffer, 0, this._stashUsed);\n            let stashNewArray = new Uint8Array(newBuffer, 0, bufferNewSize);\n            stashNewArray.set(stashOldArray, 0);\n        }\n\n        this._stashBuffer = newBuffer;\n        this._bufferSize = bufferNewSize;\n    }\n\n    _normalizeSpeed(input) {\n        let list = this._speedNormalizeList;\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        if (input < list[0]) {\n            return list[0];\n        }\n\n        // binary search\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (input >= list[mid] && input < list[mid + 1])) {\n                return list[mid];\n            } else if (list[mid] < input) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n    }\n\n    _adjustStashSize(normalized) {\n        let stashSizeKB = 0;\n\n        if (this._config.isLive) {\n            // live stream: always use single normalized speed for size of stashSizeKB\n            stashSizeKB = normalized;\n        } else {\n            if (normalized < 512) {\n                stashSizeKB = normalized;\n            } else if (normalized >= 512 && normalized <= 1024) {\n                stashSizeKB = Math.floor(normalized * 1.5);\n            } else {\n                stashSizeKB = normalized * 2;\n            }\n        }\n\n        if (stashSizeKB > 8192) {\n            stashSizeKB = 8192;\n        }\n\n        let bufferSize = stashSizeKB * 1024 + 1024 * 1024 * 1;  // stashSize + 1MB\n        if (this._bufferSize < bufferSize) {\n            this._expandBuffer(bufferSize);\n        }\n        this._stashSize = stashSizeKB * 1024;\n    }\n\n    _dispatchChunks(chunks, byteStart) {\n        this._currentRange.to = byteStart + chunks.byteLength - 1;\n        return this._onDataArrival(chunks, byteStart);\n    }\n\n    _onURLRedirect(redirectedURL) {\n        this._redirectedURL = redirectedURL;\n        if (this._onRedirect) {\n            this._onRedirect(redirectedURL);\n        }\n    }\n\n    _onContentLengthKnown(contentLength) {\n        if (contentLength && this._fullRequestFlag) {\n            this._totalLength = contentLength;\n            this._fullRequestFlag = false;\n        }\n    }\n\n    _onLoaderChunkArrival(chunk, byteStart, receivedLength) {\n        if (!this._onDataArrival) {\n            throw new IllegalStateException('IOController: No existing consumer (onDataArrival) callback!');\n        }\n        if (this._paused) {\n            return;\n        }\n        if (this._isEarlyEofReconnecting) {\n            // Auto-reconnect for EarlyEof succeed, notify to upper-layer by callback\n            this._isEarlyEofReconnecting = false;\n            if (this._onRecoveredEarlyEof) {\n                this._onRecoveredEarlyEof();\n            }\n        }\n\n        this._speedSampler.addBytes(chunk.byteLength);\n\n        // adjust stash buffer size according to network speed dynamically\n        let KBps = this._speedSampler.lastSecondKBps;\n        if (KBps !== 0) {\n            let normalized = this._normalizeSpeed(KBps);\n            if (this._speedNormalized !== normalized) {\n                this._speedNormalized = normalized;\n                this._adjustStashSize(normalized);\n            }\n        }\n\n        if (!this._enableStash) {  // disable stash\n            if (this._stashUsed === 0) {\n                // dispatch chunk directly to consumer;\n                // check ret value (consumed bytes) and stash unconsumed to stashBuffer\n                let consumed = this._dispatchChunks(chunk, byteStart);\n                if (consumed < chunk.byteLength) {  // unconsumed data remain.\n                    let remain = chunk.byteLength - consumed;\n                    if (remain > this._bufferSize) {\n                        this._expandBuffer(remain);\n                    }\n                    let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                    stashArray.set(new Uint8Array(chunk, consumed), 0);\n                    this._stashUsed += remain;\n                    this._stashByteStart = byteStart + consumed;\n                }\n            } else {\n                // else: Merge chunk into stashBuffer, and dispatch stashBuffer to consumer.\n                if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n                    this._expandBuffer(this._stashUsed + chunk.byteLength);\n                }\n                let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                stashArray.set(new Uint8Array(chunk), this._stashUsed);\n                this._stashUsed += chunk.byteLength;\n                let consumed = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);\n                if (consumed < this._stashUsed && consumed > 0) {  // unconsumed data remain\n                    let remainArray = new Uint8Array(this._stashBuffer, consumed);\n                    stashArray.set(remainArray, 0);\n                }\n                this._stashUsed -= consumed;\n                this._stashByteStart += consumed;\n            }\n        } else {  // enable stash\n            if (this._stashUsed === 0 && this._stashByteStart === 0) {  // seeked? or init chunk?\n                // This is the first chunk after seek action\n                this._stashByteStart = byteStart;\n            }\n            if (this._stashUsed + chunk.byteLength <= this._stashSize) {\n                // just stash\n                let stashArray = new Uint8Array(this._stashBuffer, 0, this._stashSize);\n                stashArray.set(new Uint8Array(chunk), this._stashUsed);\n                this._stashUsed += chunk.byteLength;\n            } else {  // stashUsed + chunkSize > stashSize, size limit exceeded\n                let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                if (this._stashUsed > 0) {  // There're stash datas in buffer\n                    // dispatch the whole stashBuffer, and stash remain data\n                    // then append chunk to stashBuffer (stash)\n                    let buffer = this._stashBuffer.slice(0, this._stashUsed);\n                    let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n                    if (consumed < buffer.byteLength) {\n                        if (consumed > 0) {\n                            let remainArray = new Uint8Array(buffer, consumed);\n                            stashArray.set(remainArray, 0);\n                            this._stashUsed = remainArray.byteLength;\n                            this._stashByteStart += consumed;\n                        }\n                    } else {\n                        this._stashUsed = 0;\n                        this._stashByteStart += consumed;\n                    }\n                    if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n                        this._expandBuffer(this._stashUsed + chunk.byteLength);\n                        stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                    }\n                    stashArray.set(new Uint8Array(chunk), this._stashUsed);\n                    this._stashUsed += chunk.byteLength;\n                } else {  // stash buffer empty, but chunkSize > stashSize (oh, holy shit)\n                    // dispatch chunk directly and stash remain data\n                    let consumed = this._dispatchChunks(chunk, byteStart);\n                    if (consumed < chunk.byteLength) {\n                        let remain = chunk.byteLength - consumed;\n                        if (remain > this._bufferSize) {\n                            this._expandBuffer(remain);\n                            stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                        }\n                        stashArray.set(new Uint8Array(chunk, consumed), 0);\n                        this._stashUsed += remain;\n                        this._stashByteStart = byteStart + consumed;\n                    }\n                }\n            }\n        }\n    }\n\n    _flushStashBuffer(dropUnconsumed) {\n        if (this._stashUsed > 0) {\n            let buffer = this._stashBuffer.slice(0, this._stashUsed);\n            let consumed = this._dispatchChunks(buffer, this._stashByteStart);\n            let remain = buffer.byteLength - consumed;\n\n            if (consumed < buffer.byteLength) {\n                if (dropUnconsumed) {\n                    Log.w(this.TAG, `${remain} bytes unconsumed data remain when flush buffer, dropped`);\n                } else {\n                    if (consumed > 0) {\n                        let stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n                        let remainArray = new Uint8Array(buffer, consumed);\n                        stashArray.set(remainArray, 0);\n                        this._stashUsed = remainArray.byteLength;\n                        this._stashByteStart += consumed;\n                    }\n                    return 0;\n                }\n            }\n            this._stashUsed = 0;\n            this._stashByteStart = 0;\n            return remain;\n        }\n        return 0;\n    }\n\n    _onLoaderComplete(from, to) {\n        // Force-flush stash buffer, and drop unconsumed data\n        this._flushStashBuffer(true);\n\n        if (this._onComplete) {\n            this._onComplete(this._extraData);\n        }\n    }\n\n    _onLoaderError(type, data) {\n        Log.e(this.TAG, `Loader error, code = ${data.code}, msg = ${data.msg}`);\n\n        this._flushStashBuffer(false);\n\n        if (this._isEarlyEofReconnecting) {\n            // Auto-reconnect for EarlyEof failed, throw UnrecoverableEarlyEof error to upper-layer\n            this._isEarlyEofReconnecting = false;\n            type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n        }\n\n        switch (type) {\n            case LoaderErrors.EARLY_EOF: {\n                if (!this._config.isLive) {\n                    // Do internal http reconnect if not live stream\n                    if (this._totalLength) {\n                        let nextFrom = this._currentRange.to + 1;\n                        if (nextFrom < this._totalLength) {\n                            Log.w(this.TAG, 'Connection lost, trying reconnect...');\n                            this._isEarlyEofReconnecting = true;\n                            this._internalSeek(nextFrom, false);\n                        }\n                        return;\n                    }\n                    // else: We don't know totalLength, throw UnrecoverableEarlyEof\n                }\n                // live stream: throw UnrecoverableEarlyEof error to upper-layer\n                type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n                break;\n            }\n            case LoaderErrors.UNRECOVERABLE_EARLY_EOF:\n            case LoaderErrors.CONNECTING_TIMEOUT:\n            case LoaderErrors.HTTP_STATUS_CODE_INVALID:\n            case LoaderErrors.EXCEPTION:\n                break;\n        }\n\n        if (this._onError) {\n            this._onError(type, data);\n        } else {\n            throw new RuntimeException('IOException: ' + data.msg);\n        }\n    }\n\n}\n\nexport default IOController;"]},"metadata":{},"sourceType":"module"}