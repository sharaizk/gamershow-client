{"ast":null,"code":"import _classCallCheck from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Utility class to calculate realtime network I/O speed\nvar SpeedSampler = /*#__PURE__*/function () {\n  function SpeedSampler() {\n    _classCallCheck(this, SpeedSampler);\n\n    // milliseconds\n    this._firstCheckpoint = 0;\n    this._lastCheckpoint = 0;\n    this._intervalBytes = 0;\n    this._totalBytes = 0;\n    this._lastSecondBytes = 0; // compatibility detection\n\n    if (self.performance && self.performance.now) {\n      this._now = self.performance.now.bind(self.performance);\n    } else {\n      this._now = Date.now;\n    }\n  }\n\n  _createClass(SpeedSampler, [{\n    key: \"reset\",\n    value: function reset() {\n      this._firstCheckpoint = this._lastCheckpoint = 0;\n      this._totalBytes = this._intervalBytes = 0;\n      this._lastSecondBytes = 0;\n    }\n  }, {\n    key: \"addBytes\",\n    value: function addBytes(bytes) {\n      if (this._firstCheckpoint === 0) {\n        this._firstCheckpoint = this._now();\n        this._lastCheckpoint = this._firstCheckpoint;\n        this._intervalBytes += bytes;\n        this._totalBytes += bytes;\n      } else if (this._now() - this._lastCheckpoint < 1000) {\n        this._intervalBytes += bytes;\n        this._totalBytes += bytes;\n      } else {\n        // duration >= 1000\n        this._lastSecondBytes = this._intervalBytes;\n        this._intervalBytes = bytes;\n        this._totalBytes += bytes;\n        this._lastCheckpoint = this._now();\n      }\n    }\n  }, {\n    key: \"currentKBps\",\n    get: function get() {\n      this.addBytes(0);\n      var durationSeconds = (this._now() - this._lastCheckpoint) / 1000;\n      if (durationSeconds == 0) durationSeconds = 1;\n      return this._intervalBytes / durationSeconds / 1024;\n    }\n  }, {\n    key: \"lastSecondKBps\",\n    get: function get() {\n      this.addBytes(0);\n\n      if (this._lastSecondBytes !== 0) {\n        return this._lastSecondBytes / 1024;\n      } else {\n        // lastSecondBytes === 0\n        if (this._now() - this._lastCheckpoint >= 500) {\n          // if time interval since last checkpoint has exceeded 500ms\n          // the speed is nearly accurate\n          return this.currentKBps;\n        } else {\n          // We don't know\n          return 0;\n        }\n      }\n    }\n  }, {\n    key: \"averageKBps\",\n    get: function get() {\n      var durationSeconds = (this._now() - this._firstCheckpoint) / 1000;\n      return this._totalBytes / durationSeconds / 1024;\n    }\n  }]);\n\n  return SpeedSampler;\n}();\n\nexport default SpeedSampler;","map":{"version":3,"sources":["D:/STREAMING_SITE/client/node_modules/flv.js/src/io/speed-sampler.js"],"names":["SpeedSampler","_firstCheckpoint","_lastCheckpoint","_intervalBytes","_totalBytes","_lastSecondBytes","self","performance","now","_now","bind","Date","bytes","addBytes","durationSeconds","currentKBps"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;IACMA,Y;AAEF,0BAAc;AAAA;;AACV;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACA,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,WAAL,GAAmB,CAAnB;AACA,SAAKC,gBAAL,GAAwB,CAAxB,CANU,CAQV;;AACA,QAAIC,IAAI,CAACC,WAAL,IAAoBD,IAAI,CAACC,WAAL,CAAiBC,GAAzC,EAA8C;AAC1C,WAAKC,IAAL,GAAYH,IAAI,CAACC,WAAL,CAAiBC,GAAjB,CAAqBE,IAArB,CAA0BJ,IAAI,CAACC,WAA/B,CAAZ;AACH,KAFD,MAEO;AACH,WAAKE,IAAL,GAAYE,IAAI,CAACH,GAAjB;AACH;AACJ;;;;WAED,iBAAQ;AACJ,WAAKP,gBAAL,GAAwB,KAAKC,eAAL,GAAuB,CAA/C;AACA,WAAKE,WAAL,GAAmB,KAAKD,cAAL,GAAsB,CAAzC;AACA,WAAKE,gBAAL,GAAwB,CAAxB;AACH;;;WAED,kBAASO,KAAT,EAAgB;AACZ,UAAI,KAAKX,gBAAL,KAA0B,CAA9B,EAAiC;AAC7B,aAAKA,gBAAL,GAAwB,KAAKQ,IAAL,EAAxB;AACA,aAAKP,eAAL,GAAuB,KAAKD,gBAA5B;AACA,aAAKE,cAAL,IAAuBS,KAAvB;AACA,aAAKR,WAAL,IAAoBQ,KAApB;AACH,OALD,MAKO,IAAI,KAAKH,IAAL,KAAc,KAAKP,eAAnB,GAAqC,IAAzC,EAA+C;AAClD,aAAKC,cAAL,IAAuBS,KAAvB;AACA,aAAKR,WAAL,IAAoBQ,KAApB;AACH,OAHM,MAGA;AAAG;AACN,aAAKP,gBAAL,GAAwB,KAAKF,cAA7B;AACA,aAAKA,cAAL,GAAsBS,KAAtB;AACA,aAAKR,WAAL,IAAoBQ,KAApB;AACA,aAAKV,eAAL,GAAuB,KAAKO,IAAL,EAAvB;AACH;AACJ;;;SAED,eAAkB;AACd,WAAKI,QAAL,CAAc,CAAd;AAEA,UAAIC,eAAe,GAAG,CAAC,KAAKL,IAAL,KAAc,KAAKP,eAApB,IAAuC,IAA7D;AACA,UAAIY,eAAe,IAAI,CAAvB,EAA0BA,eAAe,GAAG,CAAlB;AAC1B,aAAQ,KAAKX,cAAL,GAAsBW,eAAvB,GAA0C,IAAjD;AACH;;;SAED,eAAqB;AACjB,WAAKD,QAAL,CAAc,CAAd;;AAEA,UAAI,KAAKR,gBAAL,KAA0B,CAA9B,EAAiC;AAC7B,eAAO,KAAKA,gBAAL,GAAwB,IAA/B;AACH,OAFD,MAEO;AAAG;AACN,YAAI,KAAKI,IAAL,KAAc,KAAKP,eAAnB,IAAsC,GAA1C,EAA+C;AAC3C;AACA;AACA,iBAAO,KAAKa,WAAZ;AACH,SAJD,MAIO;AACH;AACA,iBAAO,CAAP;AACH;AACJ;AACJ;;;SAED,eAAkB;AACd,UAAID,eAAe,GAAG,CAAC,KAAKL,IAAL,KAAc,KAAKR,gBAApB,IAAwC,IAA9D;AACA,aAAQ,KAAKG,WAAL,GAAmBU,eAApB,GAAuC,IAA9C;AACH;;;;;;AAIL,eAAed,YAAf","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Utility class to calculate realtime network I/O speed\nclass SpeedSampler {\n\n    constructor() {\n        // milliseconds\n        this._firstCheckpoint = 0;\n        this._lastCheckpoint = 0;\n        this._intervalBytes = 0;\n        this._totalBytes = 0;\n        this._lastSecondBytes = 0;\n\n        // compatibility detection\n        if (self.performance && self.performance.now) {\n            this._now = self.performance.now.bind(self.performance);\n        } else {\n            this._now = Date.now;\n        }\n    }\n\n    reset() {\n        this._firstCheckpoint = this._lastCheckpoint = 0;\n        this._totalBytes = this._intervalBytes = 0;\n        this._lastSecondBytes = 0;\n    }\n\n    addBytes(bytes) {\n        if (this._firstCheckpoint === 0) {\n            this._firstCheckpoint = this._now();\n            this._lastCheckpoint = this._firstCheckpoint;\n            this._intervalBytes += bytes;\n            this._totalBytes += bytes;\n        } else if (this._now() - this._lastCheckpoint < 1000) {\n            this._intervalBytes += bytes;\n            this._totalBytes += bytes;\n        } else {  // duration >= 1000\n            this._lastSecondBytes = this._intervalBytes;\n            this._intervalBytes = bytes;\n            this._totalBytes += bytes;\n            this._lastCheckpoint = this._now();\n        }\n    }\n\n    get currentKBps() {\n        this.addBytes(0);\n\n        let durationSeconds = (this._now() - this._lastCheckpoint) / 1000;\n        if (durationSeconds == 0) durationSeconds = 1;\n        return (this._intervalBytes / durationSeconds) / 1024;\n    }\n\n    get lastSecondKBps() {\n        this.addBytes(0);\n\n        if (this._lastSecondBytes !== 0) {\n            return this._lastSecondBytes / 1024;\n        } else {  // lastSecondBytes === 0\n            if (this._now() - this._lastCheckpoint >= 500) {\n                // if time interval since last checkpoint has exceeded 500ms\n                // the speed is nearly accurate\n                return this.currentKBps;\n            } else {\n                // We don't know\n                return 0;\n            }\n        }\n    }\n\n    get averageKBps() {\n        let durationSeconds = (this._now() - this._firstCheckpoint) / 1000;\n        return (this._totalBytes / durationSeconds) / 1024;\n    }\n\n}\n\nexport default SpeedSampler;"]},"metadata":{},"sourceType":"module"}