{"ast":null,"code":"import _classCallCheck from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport MP4 from './mp4-generator.js';\nimport AAC from './aac-silent.js';\nimport Browser from '../utils/browser.js';\nimport { SampleInfo, MediaSegmentInfo, MediaSegmentInfoList } from '../core/media-segment-info.js';\nimport { IllegalStateException } from '../utils/exception.js'; // Fragmented mp4 remuxer\n\nvar MP4Remuxer = /*#__PURE__*/function () {\n  function MP4Remuxer(config) {\n    _classCallCheck(this, MP4Remuxer);\n\n    this.TAG = 'MP4Remuxer';\n    this._config = config;\n    this._isLive = config.isLive === true ? true : false;\n    this._dtsBase = -1;\n    this._dtsBaseInited = false;\n    this._audioDtsBase = Infinity;\n    this._videoDtsBase = Infinity;\n    this._audioNextDts = undefined;\n    this._videoNextDts = undefined;\n    this._audioStashedLastSample = null;\n    this._videoStashedLastSample = null;\n    this._audioMeta = null;\n    this._videoMeta = null;\n    this._audioSegmentInfoList = new MediaSegmentInfoList('audio');\n    this._videoSegmentInfoList = new MediaSegmentInfoList('video');\n    this._onInitSegment = null;\n    this._onMediaSegment = null; // Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n    // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n\n    this._forceFirstIDR = Browser.chrome && (Browser.version.major < 50 || Browser.version.major === 50 && Browser.version.build < 2661) ? true : false; // Workaround for IE11/Edge: Fill silent aac frame after keyframe-seeking\n    // Make audio beginDts equals with video beginDts, in order to fix seek freeze\n\n    this._fillSilentAfterSeek = Browser.msedge || Browser.msie; // While only FireFox supports 'audio/mp4, codecs=\"mp3\"', use 'audio/mpeg' for chrome, safari, ...\n\n    this._mp3UseMpegAudio = !Browser.firefox;\n    this._fillAudioTimestampGap = this._config.fixAudioTimestampGap;\n  }\n\n  _createClass(MP4Remuxer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._dtsBase = -1;\n      this._dtsBaseInited = false;\n      this._audioMeta = null;\n      this._videoMeta = null;\n\n      this._audioSegmentInfoList.clear();\n\n      this._audioSegmentInfoList = null;\n\n      this._videoSegmentInfoList.clear();\n\n      this._videoSegmentInfoList = null;\n      this._onInitSegment = null;\n      this._onMediaSegment = null;\n    }\n  }, {\n    key: \"bindDataSource\",\n    value: function bindDataSource(producer) {\n      producer.onDataAvailable = this.remux.bind(this);\n      producer.onTrackMetadata = this._onTrackMetadataReceived.bind(this);\n      return this;\n    }\n    /* prototype: function onInitSegment(type: string, initSegment: ArrayBuffer): void\n       InitSegment: {\n           type: string,\n           data: ArrayBuffer,\n           codec: string,\n           container: string\n       }\n    */\n\n  }, {\n    key: \"onInitSegment\",\n    get: function get() {\n      return this._onInitSegment;\n    },\n    set: function set(callback) {\n      this._onInitSegment = callback;\n    }\n    /* prototype: function onMediaSegment(type: string, mediaSegment: MediaSegment): void\n       MediaSegment: {\n           type: string,\n           data: ArrayBuffer,\n           sampleCount: int32\n           info: MediaSegmentInfo\n       }\n    */\n\n  }, {\n    key: \"onMediaSegment\",\n    get: function get() {\n      return this._onMediaSegment;\n    },\n    set: function set(callback) {\n      this._onMediaSegment = callback;\n    }\n  }, {\n    key: \"insertDiscontinuity\",\n    value: function insertDiscontinuity() {\n      this._audioNextDts = this._videoNextDts = undefined;\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(originalDts) {\n      this._audioStashedLastSample = null;\n      this._videoStashedLastSample = null;\n\n      this._videoSegmentInfoList.clear();\n\n      this._audioSegmentInfoList.clear();\n    }\n  }, {\n    key: \"remux\",\n    value: function remux(audioTrack, videoTrack) {\n      if (!this._onMediaSegment) {\n        throw new IllegalStateException('MP4Remuxer: onMediaSegment callback must be specificed!');\n      }\n\n      if (!this._dtsBaseInited) {\n        this._calculateDtsBase(audioTrack, videoTrack);\n      }\n\n      this._remuxVideo(videoTrack);\n\n      this._remuxAudio(audioTrack);\n    }\n  }, {\n    key: \"_onTrackMetadataReceived\",\n    value: function _onTrackMetadataReceived(type, metadata) {\n      var metabox = null;\n      var container = 'mp4';\n      var codec = metadata.codec;\n\n      if (type === 'audio') {\n        this._audioMeta = metadata;\n\n        if (metadata.codec === 'mp3' && this._mp3UseMpegAudio) {\n          // 'audio/mpeg' for MP3 audio track\n          container = 'mpeg';\n          codec = '';\n          metabox = new Uint8Array();\n        } else {\n          // 'audio/mp4, codecs=\"codec\"'\n          metabox = MP4.generateInitSegment(metadata);\n        }\n      } else if (type === 'video') {\n        this._videoMeta = metadata;\n        metabox = MP4.generateInitSegment(metadata);\n      } else {\n        return;\n      } // dispatch metabox (Initialization Segment)\n\n\n      if (!this._onInitSegment) {\n        throw new IllegalStateException('MP4Remuxer: onInitSegment callback must be specified!');\n      }\n\n      this._onInitSegment(type, {\n        type: type,\n        data: metabox.buffer,\n        codec: codec,\n        container: \"\".concat(type, \"/\").concat(container),\n        mediaDuration: metadata.duration // in timescale 1000 (milliseconds)\n\n      });\n    }\n  }, {\n    key: \"_calculateDtsBase\",\n    value: function _calculateDtsBase(audioTrack, videoTrack) {\n      if (this._dtsBaseInited) {\n        return;\n      }\n\n      if (audioTrack.samples && audioTrack.samples.length) {\n        this._audioDtsBase = audioTrack.samples[0].dts;\n      }\n\n      if (videoTrack.samples && videoTrack.samples.length) {\n        this._videoDtsBase = videoTrack.samples[0].dts;\n      }\n\n      this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);\n      this._dtsBaseInited = true;\n    }\n  }, {\n    key: \"flushStashedSamples\",\n    value: function flushStashedSamples() {\n      var videoSample = this._videoStashedLastSample;\n      var audioSample = this._audioStashedLastSample;\n      var videoTrack = {\n        type: 'video',\n        id: 1,\n        sequenceNumber: 0,\n        samples: [],\n        length: 0\n      };\n\n      if (videoSample != null) {\n        videoTrack.samples.push(videoSample);\n        videoTrack.length = videoSample.length;\n      }\n\n      var audioTrack = {\n        type: 'audio',\n        id: 2,\n        sequenceNumber: 0,\n        samples: [],\n        length: 0\n      };\n\n      if (audioSample != null) {\n        audioTrack.samples.push(audioSample);\n        audioTrack.length = audioSample.length;\n      }\n\n      this._videoStashedLastSample = null;\n      this._audioStashedLastSample = null;\n\n      this._remuxVideo(videoTrack, true);\n\n      this._remuxAudio(audioTrack, true);\n    }\n  }, {\n    key: \"_remuxAudio\",\n    value: function _remuxAudio(audioTrack, force) {\n      if (this._audioMeta == null) {\n        return;\n      }\n\n      var track = audioTrack;\n      var samples = track.samples;\n      var dtsCorrection = undefined;\n      var firstDts = -1,\n          lastDts = -1,\n          lastPts = -1;\n      var refSampleDuration = this._audioMeta.refSampleDuration;\n      var mpegRawTrack = this._audioMeta.codec === 'mp3' && this._mp3UseMpegAudio;\n      var firstSegmentAfterSeek = this._dtsBaseInited && this._audioNextDts === undefined;\n      var insertPrefixSilentFrame = false;\n\n      if (!samples || samples.length === 0) {\n        return;\n      }\n\n      if (samples.length === 1 && !force) {\n        // If [sample count in current batch] === 1 && (force != true)\n        // Ignore and keep in demuxer's queue\n        return;\n      } // else if (force === true) do remux\n\n\n      var offset = 0;\n      var mdatbox = null;\n      var mdatBytes = 0; // calculate initial mdat size\n\n      if (mpegRawTrack) {\n        // for raw mpeg buffer\n        offset = 0;\n        mdatBytes = track.length;\n      } else {\n        // for fmp4 mdat box\n        offset = 8; // size + type\n\n        mdatBytes = 8 + track.length;\n      }\n\n      var lastSample = null; // Pop the lastSample and waiting for stash\n\n      if (samples.length > 1) {\n        lastSample = samples.pop();\n        mdatBytes -= lastSample.length;\n      } // Insert [stashed lastSample in the previous batch] to the front\n\n\n      if (this._audioStashedLastSample != null) {\n        var sample = this._audioStashedLastSample;\n        this._audioStashedLastSample = null;\n        samples.unshift(sample);\n        mdatBytes += sample.length;\n      } // Stash the lastSample of current batch, waiting for next batch\n\n\n      if (lastSample != null) {\n        this._audioStashedLastSample = lastSample;\n      }\n\n      var firstSampleOriginalDts = samples[0].dts - this._dtsBase; // calculate dtsCorrection\n\n      if (this._audioNextDts) {\n        dtsCorrection = firstSampleOriginalDts - this._audioNextDts;\n      } else {\n        // this._audioNextDts == undefined\n        if (this._audioSegmentInfoList.isEmpty()) {\n          dtsCorrection = 0;\n\n          if (this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty()) {\n            if (this._audioMeta.originalCodec !== 'mp3') {\n              insertPrefixSilentFrame = true;\n            }\n          }\n        } else {\n          var _lastSample = this._audioSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n\n          if (_lastSample != null) {\n            var distance = firstSampleOriginalDts - (_lastSample.originalDts + _lastSample.duration);\n\n            if (distance <= 3) {\n              distance = 0;\n            }\n\n            var expectedDts = _lastSample.dts + _lastSample.duration + distance;\n            dtsCorrection = firstSampleOriginalDts - expectedDts;\n          } else {\n            // lastSample == null, cannot found\n            dtsCorrection = 0;\n          }\n        }\n      }\n\n      if (insertPrefixSilentFrame) {\n        // align audio segment beginDts to match with current video segment's beginDts\n        var firstSampleDts = firstSampleOriginalDts - dtsCorrection;\n\n        var videoSegment = this._videoSegmentInfoList.getLastSegmentBefore(firstSampleOriginalDts);\n\n        if (videoSegment != null && videoSegment.beginDts < firstSampleDts) {\n          var silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n\n          if (silentUnit) {\n            var dts = videoSegment.beginDts;\n            var silentFrameDuration = firstSampleDts - videoSegment.beginDts;\n            Log.v(this.TAG, \"InsertPrefixSilentAudio: dts: \".concat(dts, \", duration: \").concat(silentFrameDuration));\n            samples.unshift({\n              unit: silentUnit,\n              dts: dts,\n              pts: dts\n            });\n            mdatBytes += silentUnit.byteLength;\n          } // silentUnit == null: Cannot generate, skip\n\n        } else {\n          insertPrefixSilentFrame = false;\n        }\n      }\n\n      var mp4Samples = []; // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n\n      for (var i = 0; i < samples.length; i++) {\n        var _sample = samples[i];\n        var unit = _sample.unit;\n        var originalDts = _sample.dts - this._dtsBase;\n\n        var _dts = originalDts - dtsCorrection;\n\n        if (firstDts === -1) {\n          firstDts = _dts;\n        }\n\n        var sampleDuration = 0;\n\n        if (i !== samples.length - 1) {\n          var nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n          sampleDuration = nextDts - _dts;\n        } else {\n          // the last sample\n          if (lastSample != null) {\n            // use stashed sample's dts to calculate sample duration\n            var _nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\n\n            sampleDuration = _nextDts - _dts;\n          } else if (mp4Samples.length >= 1) {\n            // use second last sample duration\n            sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n          } else {\n            // the only one sample, use reference sample duration\n            sampleDuration = Math.floor(refSampleDuration);\n          }\n        }\n\n        var needFillSilentFrames = false;\n        var silentFrames = null; // Silent frame generation, if large timestamp gap detected && config.fixAudioTimestampGap\n\n        if (sampleDuration > refSampleDuration * 1.5 && this._audioMeta.codec !== 'mp3' && this._fillAudioTimestampGap && !Browser.safari) {\n          // We need to insert silent frames to fill timestamp gap\n          needFillSilentFrames = true;\n          var delta = Math.abs(sampleDuration - refSampleDuration);\n          var frameCount = Math.ceil(delta / refSampleDuration);\n          var currentDts = _dts + refSampleDuration; // Notice: in float\n\n          Log.w(this.TAG, 'Large audio timestamp gap detected, may cause AV sync to drift. ' + 'Silent frames will be generated to avoid unsync.\\n' + \"dts: \".concat(_dts + sampleDuration, \" ms, expected: \").concat(_dts + Math.round(refSampleDuration), \" ms, \") + \"delta: \".concat(Math.round(delta), \" ms, generate: \").concat(frameCount, \" frames\"));\n\n          var _silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n\n          if (_silentUnit == null) {\n            Log.w(this.TAG, 'Unable to generate silent frame for ' + \"\".concat(this._audioMeta.originalCodec, \" with \").concat(this._audioMeta.channelCount, \" channels, repeat last frame\")); // Repeat last frame\n\n            _silentUnit = unit;\n          }\n\n          silentFrames = [];\n\n          for (var j = 0; j < frameCount; j++) {\n            var intDts = Math.round(currentDts); // round to integer\n\n            if (silentFrames.length > 0) {\n              // Set previous frame sample duration\n              var previousFrame = silentFrames[silentFrames.length - 1];\n              previousFrame.duration = intDts - previousFrame.dts;\n            }\n\n            var frame = {\n              dts: intDts,\n              pts: intDts,\n              cts: 0,\n              unit: _silentUnit,\n              size: _silentUnit.byteLength,\n              duration: 0,\n              // wait for next sample\n              originalDts: originalDts,\n              flags: {\n                isLeading: 0,\n                dependsOn: 1,\n                isDependedOn: 0,\n                hasRedundancy: 0\n              }\n            };\n            silentFrames.push(frame);\n            mdatBytes += frame.size;\n            currentDts += refSampleDuration;\n          } // last frame: align end time to next frame dts\n\n\n          var lastFrame = silentFrames[silentFrames.length - 1];\n          lastFrame.duration = _dts + sampleDuration - lastFrame.dts; // silentFrames.forEach((frame) => {\n          //     Log.w(this.TAG, `SilentAudio: dts: ${frame.dts}, duration: ${frame.duration}`);\n          // });\n          // Set correct sample duration for current frame\n\n          sampleDuration = Math.round(refSampleDuration);\n        }\n\n        mp4Samples.push({\n          dts: _dts,\n          pts: _dts,\n          cts: 0,\n          unit: _sample.unit,\n          size: _sample.unit.byteLength,\n          duration: sampleDuration,\n          originalDts: originalDts,\n          flags: {\n            isLeading: 0,\n            dependsOn: 1,\n            isDependedOn: 0,\n            hasRedundancy: 0\n          }\n        });\n\n        if (needFillSilentFrames) {\n          // Silent frames should be inserted after wrong-duration frame\n          mp4Samples.push.apply(mp4Samples, silentFrames);\n        }\n      } // allocate mdatbox\n\n\n      if (mpegRawTrack) {\n        // allocate for raw mpeg buffer\n        mdatbox = new Uint8Array(mdatBytes);\n      } else {\n        // allocate for fmp4 mdat box\n        mdatbox = new Uint8Array(mdatBytes); // size field\n\n        mdatbox[0] = mdatBytes >>> 24 & 0xFF;\n        mdatbox[1] = mdatBytes >>> 16 & 0xFF;\n        mdatbox[2] = mdatBytes >>> 8 & 0xFF;\n        mdatbox[3] = mdatBytes & 0xFF; // type field (fourCC)\n\n        mdatbox.set(MP4.types.mdat, 4);\n      } // Write samples into mdatbox\n\n\n      for (var _i = 0; _i < mp4Samples.length; _i++) {\n        var _unit = mp4Samples[_i].unit;\n        mdatbox.set(_unit, offset);\n        offset += _unit.byteLength;\n      }\n\n      var latest = mp4Samples[mp4Samples.length - 1];\n      lastDts = latest.dts + latest.duration;\n      this._audioNextDts = lastDts; // fill media segment info & add to info list\n\n      var info = new MediaSegmentInfo();\n      info.beginDts = firstDts;\n      info.endDts = lastDts;\n      info.beginPts = firstDts;\n      info.endPts = lastDts;\n      info.originalBeginDts = mp4Samples[0].originalDts;\n      info.originalEndDts = latest.originalDts + latest.duration;\n      info.firstSample = new SampleInfo(mp4Samples[0].dts, mp4Samples[0].pts, mp4Samples[0].duration, mp4Samples[0].originalDts, false);\n      info.lastSample = new SampleInfo(latest.dts, latest.pts, latest.duration, latest.originalDts, false);\n\n      if (!this._isLive) {\n        this._audioSegmentInfoList.append(info);\n      }\n\n      track.samples = mp4Samples;\n      track.sequenceNumber++;\n      var moofbox = null;\n\n      if (mpegRawTrack) {\n        // Generate empty buffer, because useless for raw mpeg\n        moofbox = new Uint8Array();\n      } else {\n        // Generate moof for fmp4 segment\n        moofbox = MP4.moof(track, firstDts);\n      }\n\n      track.samples = [];\n      track.length = 0;\n      var segment = {\n        type: 'audio',\n        data: this._mergeBoxes(moofbox, mdatbox).buffer,\n        sampleCount: mp4Samples.length,\n        info: info\n      };\n\n      if (mpegRawTrack && firstSegmentAfterSeek) {\n        // For MPEG audio stream in MSE, if seeking occurred, before appending new buffer\n        // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n        segment.timestampOffset = firstDts;\n      }\n\n      this._onMediaSegment('audio', segment);\n    }\n  }, {\n    key: \"_remuxVideo\",\n    value: function _remuxVideo(videoTrack, force) {\n      if (this._videoMeta == null) {\n        return;\n      }\n\n      var track = videoTrack;\n      var samples = track.samples;\n      var dtsCorrection = undefined;\n      var firstDts = -1,\n          lastDts = -1;\n      var firstPts = -1,\n          lastPts = -1;\n\n      if (!samples || samples.length === 0) {\n        return;\n      }\n\n      if (samples.length === 1 && !force) {\n        // If [sample count in current batch] === 1 && (force != true)\n        // Ignore and keep in demuxer's queue\n        return;\n      } // else if (force === true) do remux\n\n\n      var offset = 8;\n      var mdatbox = null;\n      var mdatBytes = 8 + videoTrack.length;\n      var lastSample = null; // Pop the lastSample and waiting for stash\n\n      if (samples.length > 1) {\n        lastSample = samples.pop();\n        mdatBytes -= lastSample.length;\n      } // Insert [stashed lastSample in the previous batch] to the front\n\n\n      if (this._videoStashedLastSample != null) {\n        var sample = this._videoStashedLastSample;\n        this._videoStashedLastSample = null;\n        samples.unshift(sample);\n        mdatBytes += sample.length;\n      } // Stash the lastSample of current batch, waiting for next batch\n\n\n      if (lastSample != null) {\n        this._videoStashedLastSample = lastSample;\n      }\n\n      var firstSampleOriginalDts = samples[0].dts - this._dtsBase; // calculate dtsCorrection\n\n      if (this._videoNextDts) {\n        dtsCorrection = firstSampleOriginalDts - this._videoNextDts;\n      } else {\n        // this._videoNextDts == undefined\n        if (this._videoSegmentInfoList.isEmpty()) {\n          dtsCorrection = 0;\n        } else {\n          var _lastSample2 = this._videoSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n\n          if (_lastSample2 != null) {\n            var distance = firstSampleOriginalDts - (_lastSample2.originalDts + _lastSample2.duration);\n\n            if (distance <= 3) {\n              distance = 0;\n            }\n\n            var expectedDts = _lastSample2.dts + _lastSample2.duration + distance;\n            dtsCorrection = firstSampleOriginalDts - expectedDts;\n          } else {\n            // lastSample == null, cannot found\n            dtsCorrection = 0;\n          }\n        }\n      }\n\n      var info = new MediaSegmentInfo();\n      var mp4Samples = []; // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n\n      for (var i = 0; i < samples.length; i++) {\n        var _sample2 = samples[i];\n        var originalDts = _sample2.dts - this._dtsBase;\n        var isKeyframe = _sample2.isKeyframe;\n        var dts = originalDts - dtsCorrection;\n        var cts = _sample2.cts;\n        var pts = dts + cts;\n\n        if (firstDts === -1) {\n          firstDts = dts;\n          firstPts = pts;\n        }\n\n        var sampleDuration = 0;\n\n        if (i !== samples.length - 1) {\n          var nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n          sampleDuration = nextDts - dts;\n        } else {\n          // the last sample\n          if (lastSample != null) {\n            // use stashed sample's dts to calculate sample duration\n            var _nextDts2 = lastSample.dts - this._dtsBase - dtsCorrection;\n\n            sampleDuration = _nextDts2 - dts;\n          } else if (mp4Samples.length >= 1) {\n            // use second last sample duration\n            sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n          } else {\n            // the only one sample, use reference sample duration\n            sampleDuration = Math.floor(this._videoMeta.refSampleDuration);\n          }\n        }\n\n        if (isKeyframe) {\n          var syncPoint = new SampleInfo(dts, pts, sampleDuration, _sample2.dts, true);\n          syncPoint.fileposition = _sample2.fileposition;\n          info.appendSyncPoint(syncPoint);\n        }\n\n        mp4Samples.push({\n          dts: dts,\n          pts: pts,\n          cts: cts,\n          units: _sample2.units,\n          size: _sample2.length,\n          isKeyframe: isKeyframe,\n          duration: sampleDuration,\n          originalDts: originalDts,\n          flags: {\n            isLeading: 0,\n            dependsOn: isKeyframe ? 2 : 1,\n            isDependedOn: isKeyframe ? 1 : 0,\n            hasRedundancy: 0,\n            isNonSync: isKeyframe ? 0 : 1\n          }\n        });\n      } // allocate mdatbox\n\n\n      mdatbox = new Uint8Array(mdatBytes);\n      mdatbox[0] = mdatBytes >>> 24 & 0xFF;\n      mdatbox[1] = mdatBytes >>> 16 & 0xFF;\n      mdatbox[2] = mdatBytes >>> 8 & 0xFF;\n      mdatbox[3] = mdatBytes & 0xFF;\n      mdatbox.set(MP4.types.mdat, 4); // Write samples into mdatbox\n\n      for (var _i2 = 0; _i2 < mp4Samples.length; _i2++) {\n        var units = mp4Samples[_i2].units;\n\n        while (units.length) {\n          var unit = units.shift();\n          var data = unit.data;\n          mdatbox.set(data, offset);\n          offset += data.byteLength;\n        }\n      }\n\n      var latest = mp4Samples[mp4Samples.length - 1];\n      lastDts = latest.dts + latest.duration;\n      lastPts = latest.pts + latest.duration;\n      this._videoNextDts = lastDts; // fill media segment info & add to info list\n\n      info.beginDts = firstDts;\n      info.endDts = lastDts;\n      info.beginPts = firstPts;\n      info.endPts = lastPts;\n      info.originalBeginDts = mp4Samples[0].originalDts;\n      info.originalEndDts = latest.originalDts + latest.duration;\n      info.firstSample = new SampleInfo(mp4Samples[0].dts, mp4Samples[0].pts, mp4Samples[0].duration, mp4Samples[0].originalDts, mp4Samples[0].isKeyframe);\n      info.lastSample = new SampleInfo(latest.dts, latest.pts, latest.duration, latest.originalDts, latest.isKeyframe);\n\n      if (!this._isLive) {\n        this._videoSegmentInfoList.append(info);\n      }\n\n      track.samples = mp4Samples;\n      track.sequenceNumber++; // workaround for chrome < 50: force first sample as a random access point\n      // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n\n      if (this._forceFirstIDR) {\n        var flags = mp4Samples[0].flags;\n        flags.dependsOn = 2;\n        flags.isNonSync = 0;\n      }\n\n      var moofbox = MP4.moof(track, firstDts);\n      track.samples = [];\n      track.length = 0;\n\n      this._onMediaSegment('video', {\n        type: 'video',\n        data: this._mergeBoxes(moofbox, mdatbox).buffer,\n        sampleCount: mp4Samples.length,\n        info: info\n      });\n    }\n  }, {\n    key: \"_mergeBoxes\",\n    value: function _mergeBoxes(moof, mdat) {\n      var result = new Uint8Array(moof.byteLength + mdat.byteLength);\n      result.set(moof, 0);\n      result.set(mdat, moof.byteLength);\n      return result;\n    }\n  }]);\n\n  return MP4Remuxer;\n}();\n\nexport default MP4Remuxer;","map":{"version":3,"sources":["D:/STREAMING_SITE/client/node_modules/flv.js/src/remux/mp4-remuxer.js"],"names":["Log","MP4","AAC","Browser","SampleInfo","MediaSegmentInfo","MediaSegmentInfoList","IllegalStateException","MP4Remuxer","config","TAG","_config","_isLive","isLive","_dtsBase","_dtsBaseInited","_audioDtsBase","Infinity","_videoDtsBase","_audioNextDts","undefined","_videoNextDts","_audioStashedLastSample","_videoStashedLastSample","_audioMeta","_videoMeta","_audioSegmentInfoList","_videoSegmentInfoList","_onInitSegment","_onMediaSegment","_forceFirstIDR","chrome","version","major","build","_fillSilentAfterSeek","msedge","msie","_mp3UseMpegAudio","firefox","_fillAudioTimestampGap","fixAudioTimestampGap","clear","producer","onDataAvailable","remux","bind","onTrackMetadata","_onTrackMetadataReceived","callback","originalDts","audioTrack","videoTrack","_calculateDtsBase","_remuxVideo","_remuxAudio","type","metadata","metabox","container","codec","Uint8Array","generateInitSegment","data","buffer","mediaDuration","duration","samples","length","dts","Math","min","videoSample","audioSample","id","sequenceNumber","push","force","track","dtsCorrection","firstDts","lastDts","lastPts","refSampleDuration","mpegRawTrack","firstSegmentAfterSeek","insertPrefixSilentFrame","offset","mdatbox","mdatBytes","lastSample","pop","sample","unshift","firstSampleOriginalDts","isEmpty","originalCodec","getLastSampleBefore","distance","expectedDts","firstSampleDts","videoSegment","getLastSegmentBefore","beginDts","silentUnit","getSilentFrame","channelCount","silentFrameDuration","v","unit","pts","byteLength","mp4Samples","i","sampleDuration","nextDts","floor","needFillSilentFrames","silentFrames","safari","delta","abs","frameCount","ceil","currentDts","w","round","j","intDts","previousFrame","frame","cts","size","flags","isLeading","dependsOn","isDependedOn","hasRedundancy","lastFrame","apply","set","types","mdat","latest","info","endDts","beginPts","endPts","originalBeginDts","originalEndDts","firstSample","append","moofbox","moof","segment","_mergeBoxes","sampleCount","timestampOffset","firstPts","isKeyframe","syncPoint","fileposition","appendSyncPoint","units","isNonSync","shift","result"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport MP4 from './mp4-generator.js';\nimport AAC from './aac-silent.js';\nimport Browser from '../utils/browser.js';\nimport {SampleInfo, MediaSegmentInfo, MediaSegmentInfoList} from '../core/media-segment-info.js';\nimport {IllegalStateException} from '../utils/exception.js';\n\n\n// Fragmented mp4 remuxer\nclass MP4Remuxer {\n\n    constructor(config) {\n        this.TAG = 'MP4Remuxer';\n\n        this._config = config;\n        this._isLive = (config.isLive === true) ? true : false;\n\n        this._dtsBase = -1;\n        this._dtsBaseInited = false;\n        this._audioDtsBase = Infinity;\n        this._videoDtsBase = Infinity;\n        this._audioNextDts = undefined;\n        this._videoNextDts = undefined;\n        this._audioStashedLastSample = null;\n        this._videoStashedLastSample = null;\n\n        this._audioMeta = null;\n        this._videoMeta = null;\n\n        this._audioSegmentInfoList = new MediaSegmentInfoList('audio');\n        this._videoSegmentInfoList = new MediaSegmentInfoList('video');\n\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n\n        // Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        this._forceFirstIDR = (Browser.chrome &&\n                              (Browser.version.major < 50 ||\n                              (Browser.version.major === 50 && Browser.version.build < 2661))) ? true : false;\n\n        // Workaround for IE11/Edge: Fill silent aac frame after keyframe-seeking\n        // Make audio beginDts equals with video beginDts, in order to fix seek freeze\n        this._fillSilentAfterSeek = (Browser.msedge || Browser.msie);\n\n        // While only FireFox supports 'audio/mp4, codecs=\"mp3\"', use 'audio/mpeg' for chrome, safari, ...\n        this._mp3UseMpegAudio = !Browser.firefox;\n\n        this._fillAudioTimestampGap = this._config.fixAudioTimestampGap;\n    }\n\n    destroy() {\n        this._dtsBase = -1;\n        this._dtsBaseInited = false;\n        this._audioMeta = null;\n        this._videoMeta = null;\n        this._audioSegmentInfoList.clear();\n        this._audioSegmentInfoList = null;\n        this._videoSegmentInfoList.clear();\n        this._videoSegmentInfoList = null;\n        this._onInitSegment = null;\n        this._onMediaSegment = null;\n    }\n\n    bindDataSource(producer) {\n        producer.onDataAvailable = this.remux.bind(this);\n        producer.onTrackMetadata = this._onTrackMetadataReceived.bind(this);\n        return this;\n    }\n\n    /* prototype: function onInitSegment(type: string, initSegment: ArrayBuffer): void\n       InitSegment: {\n           type: string,\n           data: ArrayBuffer,\n           codec: string,\n           container: string\n       }\n    */\n    get onInitSegment() {\n        return this._onInitSegment;\n    }\n\n    set onInitSegment(callback) {\n        this._onInitSegment = callback;\n    }\n\n    /* prototype: function onMediaSegment(type: string, mediaSegment: MediaSegment): void\n       MediaSegment: {\n           type: string,\n           data: ArrayBuffer,\n           sampleCount: int32\n           info: MediaSegmentInfo\n       }\n    */\n    get onMediaSegment() {\n        return this._onMediaSegment;\n    }\n\n    set onMediaSegment(callback) {\n        this._onMediaSegment = callback;\n    }\n\n    insertDiscontinuity() {\n        this._audioNextDts = this._videoNextDts = undefined;\n    }\n\n    seek(originalDts) {\n        this._audioStashedLastSample = null;\n        this._videoStashedLastSample = null;\n        this._videoSegmentInfoList.clear();\n        this._audioSegmentInfoList.clear();\n    }\n\n    remux(audioTrack, videoTrack) {\n        if (!this._onMediaSegment) {\n            throw new IllegalStateException('MP4Remuxer: onMediaSegment callback must be specificed!');\n        }\n        if (!this._dtsBaseInited) {\n            this._calculateDtsBase(audioTrack, videoTrack);\n        }\n        this._remuxVideo(videoTrack);\n        this._remuxAudio(audioTrack);\n    }\n\n    _onTrackMetadataReceived(type, metadata) {\n        let metabox = null;\n\n        let container = 'mp4';\n        let codec = metadata.codec;\n\n        if (type === 'audio') {\n            this._audioMeta = metadata;\n            if (metadata.codec === 'mp3' && this._mp3UseMpegAudio) {\n                // 'audio/mpeg' for MP3 audio track\n                container = 'mpeg';\n                codec = '';\n                metabox = new Uint8Array();\n            } else {\n                // 'audio/mp4, codecs=\"codec\"'\n                metabox = MP4.generateInitSegment(metadata);\n            }\n        } else if (type === 'video') {\n            this._videoMeta = metadata;\n            metabox = MP4.generateInitSegment(metadata);\n        } else {\n            return;\n        }\n\n        // dispatch metabox (Initialization Segment)\n        if (!this._onInitSegment) {\n            throw new IllegalStateException('MP4Remuxer: onInitSegment callback must be specified!');\n        }\n        this._onInitSegment(type, {\n            type: type,\n            data: metabox.buffer,\n            codec: codec,\n            container: `${type}/${container}`,\n            mediaDuration: metadata.duration  // in timescale 1000 (milliseconds)\n        });\n    }\n\n    _calculateDtsBase(audioTrack, videoTrack) {\n        if (this._dtsBaseInited) {\n            return;\n        }\n\n        if (audioTrack.samples && audioTrack.samples.length) {\n            this._audioDtsBase = audioTrack.samples[0].dts;\n        }\n        if (videoTrack.samples && videoTrack.samples.length) {\n            this._videoDtsBase = videoTrack.samples[0].dts;\n        }\n\n        this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);\n        this._dtsBaseInited = true;\n    }\n\n    flushStashedSamples() {\n        let videoSample = this._videoStashedLastSample;\n        let audioSample = this._audioStashedLastSample;\n\n        let videoTrack = {\n            type: 'video',\n            id: 1,\n            sequenceNumber: 0,\n            samples: [],\n            length: 0\n        };\n\n        if (videoSample != null) {\n            videoTrack.samples.push(videoSample);\n            videoTrack.length = videoSample.length;\n        }\n\n        let audioTrack = {\n            type: 'audio',\n            id: 2,\n            sequenceNumber: 0,\n            samples: [],\n            length: 0\n        };\n\n        if (audioSample != null) {\n            audioTrack.samples.push(audioSample);\n            audioTrack.length = audioSample.length;\n        }\n\n        this._videoStashedLastSample = null;\n        this._audioStashedLastSample = null;\n\n        this._remuxVideo(videoTrack, true);\n        this._remuxAudio(audioTrack, true);\n    }\n\n    _remuxAudio(audioTrack, force) {\n        if (this._audioMeta == null) {\n            return;\n        }\n\n        let track = audioTrack;\n        let samples = track.samples;\n        let dtsCorrection = undefined;\n        let firstDts = -1, lastDts = -1, lastPts = -1;\n        let refSampleDuration = this._audioMeta.refSampleDuration;\n\n        let mpegRawTrack = this._audioMeta.codec === 'mp3' && this._mp3UseMpegAudio;\n        let firstSegmentAfterSeek = this._dtsBaseInited && this._audioNextDts === undefined;\n\n        let insertPrefixSilentFrame = false;\n\n        if (!samples || samples.length === 0) {\n            return;\n        }\n        if (samples.length === 1 && !force) {\n            // If [sample count in current batch] === 1 && (force != true)\n            // Ignore and keep in demuxer's queue\n            return;\n        }  // else if (force === true) do remux\n\n        let offset = 0;\n        let mdatbox = null;\n        let mdatBytes = 0;\n\n        // calculate initial mdat size\n        if (mpegRawTrack) {\n            // for raw mpeg buffer\n            offset = 0;\n            mdatBytes = track.length;\n        } else {\n            // for fmp4 mdat box\n            offset = 8;  // size + type\n            mdatBytes = 8 + track.length;\n        }\n\n\n        let lastSample = null;\n\n        // Pop the lastSample and waiting for stash\n        if (samples.length > 1) {\n            lastSample = samples.pop();\n            mdatBytes -= lastSample.length;\n        }\n\n        // Insert [stashed lastSample in the previous batch] to the front\n        if (this._audioStashedLastSample != null) {\n            let sample = this._audioStashedLastSample;\n            this._audioStashedLastSample = null;\n            samples.unshift(sample);\n            mdatBytes += sample.length;\n        }\n\n        // Stash the lastSample of current batch, waiting for next batch\n        if (lastSample != null) {\n            this._audioStashedLastSample = lastSample;\n        }\n\n\n        let firstSampleOriginalDts = samples[0].dts - this._dtsBase;\n\n        // calculate dtsCorrection\n        if (this._audioNextDts) {\n            dtsCorrection = firstSampleOriginalDts - this._audioNextDts;\n        } else {  // this._audioNextDts == undefined\n            if (this._audioSegmentInfoList.isEmpty()) {\n                dtsCorrection = 0;\n                if (this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty()) {\n                    if (this._audioMeta.originalCodec !== 'mp3') {\n                        insertPrefixSilentFrame = true;\n                    }\n                }\n            } else {\n                let lastSample = this._audioSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n                if (lastSample != null) {\n                    let distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\n                    if (distance <= 3) {\n                        distance = 0;\n                    }\n                    let expectedDts = lastSample.dts + lastSample.duration + distance;\n                    dtsCorrection = firstSampleOriginalDts - expectedDts;\n                } else { // lastSample == null, cannot found\n                    dtsCorrection = 0;\n                }\n            }\n        }\n\n        if (insertPrefixSilentFrame) {\n            // align audio segment beginDts to match with current video segment's beginDts\n            let firstSampleDts = firstSampleOriginalDts - dtsCorrection;\n            let videoSegment = this._videoSegmentInfoList.getLastSegmentBefore(firstSampleOriginalDts);\n            if (videoSegment != null && videoSegment.beginDts < firstSampleDts) {\n                let silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n                if (silentUnit) {\n                    let dts = videoSegment.beginDts;\n                    let silentFrameDuration = firstSampleDts - videoSegment.beginDts;\n                    Log.v(this.TAG, `InsertPrefixSilentAudio: dts: ${dts}, duration: ${silentFrameDuration}`);\n                    samples.unshift({unit: silentUnit, dts: dts, pts: dts});\n                    mdatBytes += silentUnit.byteLength;\n                }  // silentUnit == null: Cannot generate, skip\n            } else {\n                insertPrefixSilentFrame = false;\n            }\n        }\n\n        let mp4Samples = [];\n\n        // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n        for (let i = 0; i < samples.length; i++) {\n            let sample = samples[i];\n            let unit = sample.unit;\n            let originalDts = sample.dts - this._dtsBase;\n            let dts = originalDts - dtsCorrection;\n\n            if (firstDts === -1) {\n                firstDts = dts;\n            }\n\n            let sampleDuration = 0;\n\n            if (i !== samples.length - 1) {\n                let nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n                sampleDuration = nextDts - dts;\n            } else {  // the last sample\n                if (lastSample != null) {  // use stashed sample's dts to calculate sample duration\n                    let nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\n                    sampleDuration = nextDts - dts;\n                } else if (mp4Samples.length >= 1) {  // use second last sample duration\n                    sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n                } else {  // the only one sample, use reference sample duration\n                    sampleDuration = Math.floor(refSampleDuration);\n                }\n            }\n\n            let needFillSilentFrames = false;\n            let silentFrames = null;\n\n            // Silent frame generation, if large timestamp gap detected && config.fixAudioTimestampGap\n            if (sampleDuration > refSampleDuration * 1.5 && this._audioMeta.codec !== 'mp3' && this._fillAudioTimestampGap && !Browser.safari) {\n                // We need to insert silent frames to fill timestamp gap\n                needFillSilentFrames = true;\n                let delta = Math.abs(sampleDuration - refSampleDuration);\n                let frameCount = Math.ceil(delta / refSampleDuration);\n                let currentDts = dts + refSampleDuration;  // Notice: in float\n\n                Log.w(this.TAG, 'Large audio timestamp gap detected, may cause AV sync to drift. ' +\n                                'Silent frames will be generated to avoid unsync.\\n' +\n                                `dts: ${dts + sampleDuration} ms, expected: ${dts + Math.round(refSampleDuration)} ms, ` +\n                                `delta: ${Math.round(delta)} ms, generate: ${frameCount} frames`);\n\n                let silentUnit = AAC.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);\n                if (silentUnit == null) {\n                    Log.w(this.TAG, 'Unable to generate silent frame for ' +\n                                    `${this._audioMeta.originalCodec} with ${this._audioMeta.channelCount} channels, repeat last frame`);\n                    // Repeat last frame\n                    silentUnit = unit;\n                }\n                silentFrames = [];\n\n                for (let j = 0; j < frameCount; j++) {\n                    let intDts = Math.round(currentDts);  // round to integer\n                    if (silentFrames.length > 0) {\n                        // Set previous frame sample duration\n                        let previousFrame = silentFrames[silentFrames.length - 1];\n                        previousFrame.duration = intDts - previousFrame.dts;\n                    }\n                    let frame = {\n                        dts: intDts,\n                        pts: intDts,\n                        cts: 0,\n                        unit: silentUnit,\n                        size: silentUnit.byteLength,\n                        duration: 0,  // wait for next sample\n                        originalDts: originalDts,\n                        flags: {\n                            isLeading: 0,\n                            dependsOn: 1,\n                            isDependedOn: 0,\n                            hasRedundancy: 0\n                        }\n                    };\n                    silentFrames.push(frame);\n                    mdatBytes += frame.size;\n                    currentDts += refSampleDuration;\n                }\n\n                // last frame: align end time to next frame dts\n                let lastFrame = silentFrames[silentFrames.length - 1];\n                lastFrame.duration = dts + sampleDuration - lastFrame.dts;\n\n                // silentFrames.forEach((frame) => {\n                //     Log.w(this.TAG, `SilentAudio: dts: ${frame.dts}, duration: ${frame.duration}`);\n                // });\n\n                // Set correct sample duration for current frame\n                sampleDuration = Math.round(refSampleDuration);\n            }\n\n            mp4Samples.push({\n                dts: dts,\n                pts: dts,\n                cts: 0,\n                unit: sample.unit,\n                size: sample.unit.byteLength,\n                duration: sampleDuration,\n                originalDts: originalDts,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: 1,\n                    isDependedOn: 0,\n                    hasRedundancy: 0\n                }\n            });\n\n            if (needFillSilentFrames) {\n                // Silent frames should be inserted after wrong-duration frame\n                mp4Samples.push.apply(mp4Samples, silentFrames);\n            }\n        }\n\n        // allocate mdatbox\n        if (mpegRawTrack) {\n            // allocate for raw mpeg buffer\n            mdatbox = new Uint8Array(mdatBytes);\n        } else {\n            // allocate for fmp4 mdat box\n            mdatbox = new Uint8Array(mdatBytes);\n            // size field\n            mdatbox[0] = (mdatBytes >>> 24) & 0xFF;\n            mdatbox[1] = (mdatBytes >>> 16) & 0xFF;\n            mdatbox[2] = (mdatBytes >>>  8) & 0xFF;\n            mdatbox[3] = (mdatBytes) & 0xFF;\n            // type field (fourCC)\n            mdatbox.set(MP4.types.mdat, 4);\n        }\n\n        // Write samples into mdatbox\n        for (let i = 0; i < mp4Samples.length; i++) {\n            let unit = mp4Samples[i].unit;\n            mdatbox.set(unit, offset);\n            offset += unit.byteLength;\n        }\n\n        let latest = mp4Samples[mp4Samples.length - 1];\n        lastDts = latest.dts + latest.duration;\n        this._audioNextDts = lastDts;\n\n        // fill media segment info & add to info list\n        let info = new MediaSegmentInfo();\n        info.beginDts = firstDts;\n        info.endDts = lastDts;\n        info.beginPts = firstDts;\n        info.endPts = lastDts;\n        info.originalBeginDts = mp4Samples[0].originalDts;\n        info.originalEndDts = latest.originalDts + latest.duration;\n        info.firstSample = new SampleInfo(mp4Samples[0].dts,\n                                          mp4Samples[0].pts,\n                                          mp4Samples[0].duration,\n                                          mp4Samples[0].originalDts,\n                                          false);\n        info.lastSample = new SampleInfo(latest.dts,\n                                         latest.pts,\n                                         latest.duration,\n                                         latest.originalDts,\n                                         false);\n        if (!this._isLive) {\n            this._audioSegmentInfoList.append(info);\n        }\n\n        track.samples = mp4Samples;\n        track.sequenceNumber++;\n\n        let moofbox = null;\n\n        if (mpegRawTrack) {\n            // Generate empty buffer, because useless for raw mpeg\n            moofbox = new Uint8Array();\n        } else {\n            // Generate moof for fmp4 segment\n            moofbox = MP4.moof(track, firstDts);\n        }\n\n        track.samples = [];\n        track.length = 0;\n\n        let segment = {\n            type: 'audio',\n            data: this._mergeBoxes(moofbox, mdatbox).buffer,\n            sampleCount: mp4Samples.length,\n            info: info\n        };\n\n        if (mpegRawTrack && firstSegmentAfterSeek) {\n            // For MPEG audio stream in MSE, if seeking occurred, before appending new buffer\n            // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n            segment.timestampOffset = firstDts;\n        }\n\n        this._onMediaSegment('audio', segment);\n    }\n\n    _remuxVideo(videoTrack, force) {\n        if (this._videoMeta == null) {\n            return;\n        }\n\n        let track = videoTrack;\n        let samples = track.samples;\n        let dtsCorrection = undefined;\n        let firstDts = -1, lastDts = -1;\n        let firstPts = -1, lastPts = -1;\n\n        if (!samples || samples.length === 0) {\n            return;\n        }\n        if (samples.length === 1 && !force) {\n            // If [sample count in current batch] === 1 && (force != true)\n            // Ignore and keep in demuxer's queue\n            return;\n        }  // else if (force === true) do remux\n\n        let offset = 8;\n        let mdatbox = null;\n        let mdatBytes = 8 + videoTrack.length;\n\n\n        let lastSample = null;\n\n        // Pop the lastSample and waiting for stash\n        if (samples.length > 1) {\n            lastSample = samples.pop();\n            mdatBytes -= lastSample.length;\n        }\n\n        // Insert [stashed lastSample in the previous batch] to the front\n        if (this._videoStashedLastSample != null) {\n            let sample = this._videoStashedLastSample;\n            this._videoStashedLastSample = null;\n            samples.unshift(sample);\n            mdatBytes += sample.length;\n        }\n\n        // Stash the lastSample of current batch, waiting for next batch\n        if (lastSample != null) {\n            this._videoStashedLastSample = lastSample;\n        }\n\n\n        let firstSampleOriginalDts = samples[0].dts - this._dtsBase;\n\n        // calculate dtsCorrection\n        if (this._videoNextDts) {\n            dtsCorrection = firstSampleOriginalDts - this._videoNextDts;\n        } else {  // this._videoNextDts == undefined\n            if (this._videoSegmentInfoList.isEmpty()) {\n                dtsCorrection = 0;\n            } else {\n                let lastSample = this._videoSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);\n                if (lastSample != null) {\n                    let distance = (firstSampleOriginalDts - (lastSample.originalDts + lastSample.duration));\n                    if (distance <= 3) {\n                        distance = 0;\n                    }\n                    let expectedDts = lastSample.dts + lastSample.duration + distance;\n                    dtsCorrection = firstSampleOriginalDts - expectedDts;\n                } else { // lastSample == null, cannot found\n                    dtsCorrection = 0;\n                }\n            }\n        }\n\n        let info = new MediaSegmentInfo();\n        let mp4Samples = [];\n\n        // Correct dts for each sample, and calculate sample duration. Then output to mp4Samples\n        for (let i = 0; i < samples.length; i++) {\n            let sample = samples[i];\n            let originalDts = sample.dts - this._dtsBase;\n            let isKeyframe = sample.isKeyframe;\n            let dts = originalDts - dtsCorrection;\n            let cts = sample.cts;\n            let pts = dts + cts;\n\n            if (firstDts === -1) {\n                firstDts = dts;\n                firstPts = pts;\n            }\n\n            let sampleDuration = 0;\n\n            if (i !== samples.length - 1) {\n                let nextDts = samples[i + 1].dts - this._dtsBase - dtsCorrection;\n                sampleDuration = nextDts - dts;\n            } else {  // the last sample\n                if (lastSample != null) {  // use stashed sample's dts to calculate sample duration\n                    let nextDts = lastSample.dts - this._dtsBase - dtsCorrection;\n                    sampleDuration = nextDts - dts;\n                } else if (mp4Samples.length >= 1) {  // use second last sample duration\n                    sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n                } else {  // the only one sample, use reference sample duration\n                    sampleDuration = Math.floor(this._videoMeta.refSampleDuration);\n                }\n            }\n\n            if (isKeyframe) {\n                let syncPoint = new SampleInfo(dts, pts, sampleDuration, sample.dts, true);\n                syncPoint.fileposition = sample.fileposition;\n                info.appendSyncPoint(syncPoint);\n            }\n\n            mp4Samples.push({\n                dts: dts,\n                pts: pts,\n                cts: cts,\n                units: sample.units,\n                size: sample.length,\n                isKeyframe: isKeyframe,\n                duration: sampleDuration,\n                originalDts: originalDts,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: isKeyframe ? 2 : 1,\n                    isDependedOn: isKeyframe ? 1 : 0,\n                    hasRedundancy: 0,\n                    isNonSync: isKeyframe ? 0 : 1\n                }\n            });\n        }\n\n        // allocate mdatbox\n        mdatbox = new Uint8Array(mdatBytes);\n        mdatbox[0] = (mdatBytes >>> 24) & 0xFF;\n        mdatbox[1] = (mdatBytes >>> 16) & 0xFF;\n        mdatbox[2] = (mdatBytes >>>  8) & 0xFF;\n        mdatbox[3] = (mdatBytes) & 0xFF;\n        mdatbox.set(MP4.types.mdat, 4);\n\n        // Write samples into mdatbox\n        for (let i = 0; i < mp4Samples.length; i++) {\n            let units = mp4Samples[i].units;\n            while (units.length) {\n                let unit = units.shift();\n                let data = unit.data;\n                mdatbox.set(data, offset);\n                offset += data.byteLength;\n            }\n        }\n\n        let latest = mp4Samples[mp4Samples.length - 1];\n        lastDts = latest.dts + latest.duration;\n        lastPts = latest.pts + latest.duration;\n        this._videoNextDts = lastDts;\n\n        // fill media segment info & add to info list\n        info.beginDts = firstDts;\n        info.endDts = lastDts;\n        info.beginPts = firstPts;\n        info.endPts = lastPts;\n        info.originalBeginDts = mp4Samples[0].originalDts;\n        info.originalEndDts = latest.originalDts + latest.duration;\n        info.firstSample = new SampleInfo(mp4Samples[0].dts,\n                                          mp4Samples[0].pts,\n                                          mp4Samples[0].duration,\n                                          mp4Samples[0].originalDts,\n                                          mp4Samples[0].isKeyframe);\n        info.lastSample = new SampleInfo(latest.dts,\n                                         latest.pts,\n                                         latest.duration,\n                                         latest.originalDts,\n                                         latest.isKeyframe);\n        if (!this._isLive) {\n            this._videoSegmentInfoList.append(info);\n        }\n\n        track.samples = mp4Samples;\n        track.sequenceNumber++;\n\n        // workaround for chrome < 50: force first sample as a random access point\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        if (this._forceFirstIDR) {\n            let flags = mp4Samples[0].flags;\n            flags.dependsOn = 2;\n            flags.isNonSync = 0;\n        }\n\n        let moofbox = MP4.moof(track, firstDts);\n        track.samples = [];\n        track.length = 0;\n\n        this._onMediaSegment('video', {\n            type: 'video',\n            data: this._mergeBoxes(moofbox, mdatbox).buffer,\n            sampleCount: mp4Samples.length,\n            info: info\n        });\n    }\n\n    _mergeBoxes(moof, mdat) {\n        let result = new Uint8Array(moof.byteLength + mdat.byteLength);\n        result.set(moof, 0);\n        result.set(mdat, moof.byteLength);\n        return result;\n    }\n\n}\n\nexport default MP4Remuxer;"]},"metadata":{},"sourceType":"module"}