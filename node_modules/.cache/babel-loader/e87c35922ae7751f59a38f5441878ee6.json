{"ast":null,"code":"import _createClass from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Represents an media sample (audio / video)\nexport var SampleInfo = function SampleInfo(dts, pts, duration, originalDts, isSync) {\n  _classCallCheck(this, SampleInfo);\n\n  this.dts = dts;\n  this.pts = pts;\n  this.duration = duration;\n  this.originalDts = originalDts;\n  this.isSyncPoint = isSync;\n  this.fileposition = null;\n}; // Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\n\nexport var MediaSegmentInfo = /*#__PURE__*/function () {\n  function MediaSegmentInfo() {\n    _classCallCheck(this, MediaSegmentInfo);\n\n    this.beginDts = 0;\n    this.endDts = 0;\n    this.beginPts = 0;\n    this.endPts = 0;\n    this.originalBeginDts = 0;\n    this.originalEndDts = 0;\n    this.syncPoints = []; // SampleInfo[n], for video IDR frames only\n\n    this.firstSample = null; // SampleInfo\n\n    this.lastSample = null; // SampleInfo\n  }\n\n  _createClass(MediaSegmentInfo, [{\n    key: \"appendSyncPoint\",\n    value: function appendSyncPoint(sampleInfo) {\n      // also called Random Access Point\n      sampleInfo.isSyncPoint = true;\n      this.syncPoints.push(sampleInfo);\n    }\n  }]);\n\n  return MediaSegmentInfo;\n}(); // Ordered list for recording video IDR frames, sorted by originalDts\n\nexport var IDRSampleList = /*#__PURE__*/function () {\n  function IDRSampleList() {\n    _classCallCheck(this, IDRSampleList);\n\n    this._list = [];\n  }\n\n  _createClass(IDRSampleList, [{\n    key: \"clear\",\n    value: function clear() {\n      this._list = [];\n    }\n  }, {\n    key: \"appendArray\",\n    value: function appendArray(syncPoints) {\n      var list = this._list;\n\n      if (syncPoints.length === 0) {\n        return;\n      }\n\n      if (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n        this.clear();\n      }\n\n      Array.prototype.push.apply(list, syncPoints);\n    }\n  }, {\n    key: \"getLastSyncPointBeforeDts\",\n    value: function getLastSyncPointBeforeDts(dts) {\n      if (this._list.length == 0) {\n        return null;\n      }\n\n      var list = this._list;\n      var idx = 0;\n      var last = list.length - 1;\n      var mid = 0;\n      var lbound = 0;\n      var ubound = last;\n\n      if (dts < list[0].dts) {\n        idx = 0;\n        lbound = ubound + 1;\n      }\n\n      while (lbound <= ubound) {\n        mid = lbound + Math.floor((ubound - lbound) / 2);\n\n        if (mid === last || dts >= list[mid].dts && dts < list[mid + 1].dts) {\n          idx = mid;\n          break;\n        } else if (list[mid].dts < dts) {\n          lbound = mid + 1;\n        } else {\n          ubound = mid - 1;\n        }\n      }\n\n      return this._list[idx];\n    }\n  }]);\n\n  return IDRSampleList;\n}(); // Data structure for recording information of media segments in single track.\n\nexport var MediaSegmentInfoList = /*#__PURE__*/function () {\n  function MediaSegmentInfoList(type) {\n    _classCallCheck(this, MediaSegmentInfoList);\n\n    this._type = type;\n    this._list = [];\n    this._lastAppendLocation = -1; // cached last insert location\n  }\n\n  _createClass(MediaSegmentInfoList, [{\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._list.length;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._list.length === 0;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._list = [];\n      this._lastAppendLocation = -1;\n    }\n  }, {\n    key: \"_searchNearestSegmentBefore\",\n    value: function _searchNearestSegmentBefore(originalBeginDts) {\n      var list = this._list;\n\n      if (list.length === 0) {\n        return -2;\n      }\n\n      var last = list.length - 1;\n      var mid = 0;\n      var lbound = 0;\n      var ubound = last;\n      var idx = 0;\n\n      if (originalBeginDts < list[0].originalBeginDts) {\n        idx = -1;\n        return idx;\n      }\n\n      while (lbound <= ubound) {\n        mid = lbound + Math.floor((ubound - lbound) / 2);\n\n        if (mid === last || originalBeginDts > list[mid].lastSample.originalDts && originalBeginDts < list[mid + 1].originalBeginDts) {\n          idx = mid;\n          break;\n        } else if (list[mid].originalBeginDts < originalBeginDts) {\n          lbound = mid + 1;\n        } else {\n          ubound = mid - 1;\n        }\n      }\n\n      return idx;\n    }\n  }, {\n    key: \"_searchNearestSegmentAfter\",\n    value: function _searchNearestSegmentAfter(originalBeginDts) {\n      return this._searchNearestSegmentBefore(originalBeginDts) + 1;\n    }\n  }, {\n    key: \"append\",\n    value: function append(mediaSegmentInfo) {\n      var list = this._list;\n      var msi = mediaSegmentInfo;\n      var lastAppendIdx = this._lastAppendLocation;\n      var insertIdx = 0;\n\n      if (lastAppendIdx !== -1 && lastAppendIdx < list.length && msi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts && (lastAppendIdx === list.length - 1 || lastAppendIdx < list.length - 1 && msi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts)) {\n        insertIdx = lastAppendIdx + 1; // use cached location idx\n      } else {\n        if (list.length > 0) {\n          insertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n        }\n      }\n\n      this._lastAppendLocation = insertIdx;\n\n      this._list.splice(insertIdx, 0, msi);\n    }\n  }, {\n    key: \"getLastSegmentBefore\",\n    value: function getLastSegmentBefore(originalBeginDts) {\n      var idx = this._searchNearestSegmentBefore(originalBeginDts);\n\n      if (idx >= 0) {\n        return this._list[idx];\n      } else {\n        // -1\n        return null;\n      }\n    }\n  }, {\n    key: \"getLastSampleBefore\",\n    value: function getLastSampleBefore(originalBeginDts) {\n      var segment = this.getLastSegmentBefore(originalBeginDts);\n\n      if (segment != null) {\n        return segment.lastSample;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"getLastSyncPointBefore\",\n    value: function getLastSyncPointBefore(originalBeginDts) {\n      var segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n\n      var syncPoints = this._list[segmentIdx].syncPoints;\n\n      while (syncPoints.length === 0 && segmentIdx > 0) {\n        segmentIdx--;\n        syncPoints = this._list[segmentIdx].syncPoints;\n      }\n\n      if (syncPoints.length > 0) {\n        return syncPoints[syncPoints.length - 1];\n      } else {\n        return null;\n      }\n    }\n  }]);\n\n  return MediaSegmentInfoList;\n}();","map":{"version":3,"sources":["D:/STREAMING_SITE/client/node_modules/flv.js/src/core/media-segment-info.js"],"names":["SampleInfo","dts","pts","duration","originalDts","isSync","isSyncPoint","fileposition","MediaSegmentInfo","beginDts","endDts","beginPts","endPts","originalBeginDts","originalEndDts","syncPoints","firstSample","lastSample","sampleInfo","push","IDRSampleList","_list","list","length","clear","Array","prototype","apply","idx","last","mid","lbound","ubound","Math","floor","MediaSegmentInfoList","type","_type","_lastAppendLocation","_searchNearestSegmentBefore","mediaSegmentInfo","msi","lastAppendIdx","insertIdx","splice","segment","getLastSegmentBefore","segmentIdx"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Represents an media sample (audio / video)\nexport class SampleInfo {\n\n    constructor(dts, pts, duration, originalDts, isSync) {\n        this.dts = dts;\n        this.pts = pts;\n        this.duration = duration;\n        this.originalDts = originalDts;\n        this.isSyncPoint = isSync;\n        this.fileposition = null;\n    }\n\n}\n\n// Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\nexport class MediaSegmentInfo {\n\n    constructor() {\n        this.beginDts = 0;\n        this.endDts = 0;\n        this.beginPts = 0;\n        this.endPts = 0;\n        this.originalBeginDts = 0;\n        this.originalEndDts = 0;\n        this.syncPoints = [];     // SampleInfo[n], for video IDR frames only\n        this.firstSample = null;  // SampleInfo\n        this.lastSample = null;   // SampleInfo\n    }\n\n    appendSyncPoint(sampleInfo) {  // also called Random Access Point\n        sampleInfo.isSyncPoint = true;\n        this.syncPoints.push(sampleInfo);\n    }\n\n}\n\n// Ordered list for recording video IDR frames, sorted by originalDts\nexport class IDRSampleList {\n\n    constructor() {\n        this._list = [];\n    }\n\n    clear() {\n        this._list = [];\n    }\n\n    appendArray(syncPoints) {\n        let list = this._list;\n\n        if (syncPoints.length === 0) {\n            return;\n        }\n\n        if (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n            this.clear();\n        }\n\n        Array.prototype.push.apply(list, syncPoints);\n    }\n\n    getLastSyncPointBeforeDts(dts) {\n        if (this._list.length == 0) {\n            return null;\n        }\n\n        let list = this._list;\n        let idx = 0;\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        if (dts < list[0].dts) {\n            idx = 0;\n            lbound = ubound + 1;\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (dts >= list[mid].dts && dts < list[mid + 1].dts)) {\n                idx = mid;\n                break;\n            } else if (list[mid].dts < dts) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n        return this._list[idx];\n    }\n\n}\n\n// Data structure for recording information of media segments in single track.\nexport class MediaSegmentInfoList {\n\n    constructor(type) {\n        this._type = type;\n        this._list = [];\n        this._lastAppendLocation = -1;  // cached last insert location\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    get length() {\n        return this._list.length;\n    }\n\n    isEmpty() {\n        return this._list.length === 0;\n    }\n\n    clear() {\n        this._list = [];\n        this._lastAppendLocation = -1;\n    }\n\n    _searchNearestSegmentBefore(originalBeginDts) {\n        let list = this._list;\n        if (list.length === 0) {\n            return -2;\n        }\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        let idx = 0;\n\n        if (originalBeginDts < list[0].originalBeginDts) {\n            idx = -1;\n            return idx;\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || (originalBeginDts > list[mid].lastSample.originalDts &&\n                                (originalBeginDts < list[mid + 1].originalBeginDts))) {\n                idx = mid;\n                break;\n            } else if (list[mid].originalBeginDts < originalBeginDts) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n        return idx;\n    }\n\n    _searchNearestSegmentAfter(originalBeginDts) {\n        return this._searchNearestSegmentBefore(originalBeginDts) + 1;\n    }\n\n    append(mediaSegmentInfo) {\n        let list = this._list;\n        let msi = mediaSegmentInfo;\n        let lastAppendIdx = this._lastAppendLocation;\n        let insertIdx = 0;\n\n        if (lastAppendIdx !== -1 && lastAppendIdx < list.length &&\n                                    msi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts &&\n                                    ((lastAppendIdx === list.length - 1) ||\n                                    (lastAppendIdx < list.length - 1 &&\n                                    msi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts))) {\n            insertIdx = lastAppendIdx + 1;  // use cached location idx\n        } else {\n            if (list.length > 0) {\n                insertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n            }\n        }\n\n        this._lastAppendLocation = insertIdx;\n        this._list.splice(insertIdx, 0, msi);\n    }\n\n    getLastSegmentBefore(originalBeginDts) {\n        let idx = this._searchNearestSegmentBefore(originalBeginDts);\n        if (idx >= 0) {\n            return this._list[idx];\n        } else {  // -1\n            return null;\n        }\n    }\n\n    getLastSampleBefore(originalBeginDts) {\n        let segment = this.getLastSegmentBefore(originalBeginDts);\n        if (segment != null) {\n            return segment.lastSample;\n        } else {\n            return null;\n        }\n    }\n\n    getLastSyncPointBefore(originalBeginDts) {\n        let segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n        let syncPoints = this._list[segmentIdx].syncPoints;\n        while (syncPoints.length === 0 && segmentIdx > 0) {\n            segmentIdx--;\n            syncPoints = this._list[segmentIdx].syncPoints;\n        }\n        if (syncPoints.length > 0) {\n            return syncPoints[syncPoints.length - 1];\n        } else {\n            return null;\n        }\n    }\n\n}"]},"metadata":{},"sourceType":"module"}