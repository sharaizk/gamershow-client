{"ast":null,"code":"import _classCallCheck from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MediaInfo from './media-info.js';\nimport FLVDemuxer from '../demux/flv-demuxer.js';\nimport MP4Remuxer from '../remux/mp4-remuxer.js';\nimport DemuxErrors from '../demux/demux-errors.js';\nimport IOController from '../io/io-controller.js';\nimport TransmuxingEvents from './transmuxing-events.js';\nimport { LoaderStatus, LoaderErrors } from '../io/loader.js'; // Transmuxing (IO, Demuxing, Remuxing) controller, with multipart support\n\nvar TransmuxingController = /*#__PURE__*/function () {\n  function TransmuxingController(mediaDataSource, config) {\n    _classCallCheck(this, TransmuxingController);\n\n    this.TAG = 'TransmuxingController';\n    this._emitter = new EventEmitter();\n    this._config = config; // treat single part media as multipart media, which has only one segment\n\n    if (!mediaDataSource.segments) {\n      mediaDataSource.segments = [{\n        duration: mediaDataSource.duration,\n        filesize: mediaDataSource.filesize,\n        url: mediaDataSource.url\n      }];\n    } // fill in default IO params if not exists\n\n\n    if (typeof mediaDataSource.cors !== 'boolean') {\n      mediaDataSource.cors = true;\n    }\n\n    if (typeof mediaDataSource.withCredentials !== 'boolean') {\n      mediaDataSource.withCredentials = false;\n    }\n\n    this._mediaDataSource = mediaDataSource;\n    this._currentSegmentIndex = 0;\n    var totalDuration = 0;\n\n    this._mediaDataSource.segments.forEach(function (segment) {\n      // timestampBase for each segment, and calculate total duration\n      segment.timestampBase = totalDuration;\n      totalDuration += segment.duration; // params needed by IOController\n\n      segment.cors = mediaDataSource.cors;\n      segment.withCredentials = mediaDataSource.withCredentials; // referrer policy control, if exist\n\n      if (config.referrerPolicy) {\n        segment.referrerPolicy = config.referrerPolicy;\n      }\n    });\n\n    if (!isNaN(totalDuration) && this._mediaDataSource.duration !== totalDuration) {\n      this._mediaDataSource.duration = totalDuration;\n    }\n\n    this._mediaInfo = null;\n    this._demuxer = null;\n    this._remuxer = null;\n    this._ioctl = null;\n    this._pendingSeekTime = null;\n    this._pendingResolveSeekPoint = null;\n    this._statisticsReporter = null;\n  }\n\n  _createClass(TransmuxingController, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._mediaInfo = null;\n      this._mediaDataSource = null;\n\n      if (this._statisticsReporter) {\n        this._disableStatisticsReporter();\n      }\n\n      if (this._ioctl) {\n        this._ioctl.destroy();\n\n        this._ioctl = null;\n      }\n\n      if (this._demuxer) {\n        this._demuxer.destroy();\n\n        this._demuxer = null;\n      }\n\n      if (this._remuxer) {\n        this._remuxer.destroy();\n\n        this._remuxer = null;\n      }\n\n      this._emitter.removeAllListeners();\n\n      this._emitter = null;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this._emitter.addListener(event, listener);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this._emitter.removeListener(event, listener);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._loadSegment(0);\n\n      this._enableStatisticsReporter();\n    }\n  }, {\n    key: \"_loadSegment\",\n    value: function _loadSegment(segmentIndex, optionalFrom) {\n      this._currentSegmentIndex = segmentIndex;\n      var dataSource = this._mediaDataSource.segments[segmentIndex];\n      var ioctl = this._ioctl = new IOController(dataSource, this._config, segmentIndex);\n      ioctl.onError = this._onIOException.bind(this);\n      ioctl.onSeeked = this._onIOSeeked.bind(this);\n      ioctl.onComplete = this._onIOComplete.bind(this);\n      ioctl.onRedirect = this._onIORedirect.bind(this);\n      ioctl.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this);\n\n      if (optionalFrom) {\n        this._demuxer.bindDataSource(this._ioctl);\n      } else {\n        ioctl.onDataArrival = this._onInitChunkArrival.bind(this);\n      }\n\n      ioctl.open(optionalFrom);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._internalAbort();\n\n      this._disableStatisticsReporter();\n    }\n  }, {\n    key: \"_internalAbort\",\n    value: function _internalAbort() {\n      if (this._ioctl) {\n        this._ioctl.destroy();\n\n        this._ioctl = null;\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      // take a rest\n      if (this._ioctl && this._ioctl.isWorking()) {\n        this._ioctl.pause();\n\n        this._disableStatisticsReporter();\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._ioctl && this._ioctl.isPaused()) {\n        this._ioctl.resume();\n\n        this._enableStatisticsReporter();\n      }\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(milliseconds) {\n      if (this._mediaInfo == null || !this._mediaInfo.isSeekable()) {\n        return;\n      }\n\n      var targetSegmentIndex = this._searchSegmentIndexContains(milliseconds);\n\n      if (targetSegmentIndex === this._currentSegmentIndex) {\n        // intra-segment seeking\n        var segmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n        if (segmentInfo == undefined) {\n          // current segment loading started, but mediainfo hasn't received yet\n          // wait for the metadata loaded, then seek to expected position\n          this._pendingSeekTime = milliseconds;\n        } else {\n          var keyframe = segmentInfo.getNearestKeyframe(milliseconds);\n\n          this._remuxer.seek(keyframe.milliseconds);\n\n          this._ioctl.seek(keyframe.fileposition); // Will be resolved in _onRemuxerMediaSegmentArrival()\n\n\n          this._pendingResolveSeekPoint = keyframe.milliseconds;\n        }\n      } else {\n        // cross-segment seeking\n        var targetSegmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n        if (targetSegmentInfo == undefined) {\n          // target segment hasn't been loaded. We need metadata then seek to expected time\n          this._pendingSeekTime = milliseconds;\n\n          this._internalAbort();\n\n          this._remuxer.seek();\n\n          this._remuxer.insertDiscontinuity();\n\n          this._loadSegment(targetSegmentIndex); // Here we wait for the metadata loaded, then seek to expected position\n\n        } else {\n          // We have target segment's metadata, direct seek to target position\n          var _keyframe = targetSegmentInfo.getNearestKeyframe(milliseconds);\n\n          this._internalAbort();\n\n          this._remuxer.seek(milliseconds);\n\n          this._remuxer.insertDiscontinuity();\n\n          this._demuxer.resetMediaInfo();\n\n          this._demuxer.timestampBase = this._mediaDataSource.segments[targetSegmentIndex].timestampBase;\n\n          this._loadSegment(targetSegmentIndex, _keyframe.fileposition);\n\n          this._pendingResolveSeekPoint = _keyframe.milliseconds;\n\n          this._reportSegmentMediaInfo(targetSegmentIndex);\n        }\n      }\n\n      this._enableStatisticsReporter();\n    }\n  }, {\n    key: \"_searchSegmentIndexContains\",\n    value: function _searchSegmentIndexContains(milliseconds) {\n      var segments = this._mediaDataSource.segments;\n      var idx = segments.length - 1;\n\n      for (var i = 0; i < segments.length; i++) {\n        if (milliseconds < segments[i].timestampBase) {\n          idx = i - 1;\n          break;\n        }\n      }\n\n      return idx;\n    }\n  }, {\n    key: \"_onInitChunkArrival\",\n    value: function _onInitChunkArrival(data, byteStart) {\n      var _this = this;\n\n      var probeData = null;\n      var consumed = 0;\n\n      if (byteStart > 0) {\n        // IOController seeked immediately after opened, byteStart > 0 callback may received\n        this._demuxer.bindDataSource(this._ioctl);\n\n        this._demuxer.timestampBase = this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase;\n        consumed = this._demuxer.parseChunks(data, byteStart);\n      } else if ((probeData = FLVDemuxer.probe(data)).match) {\n        // Always create new FLVDemuxer\n        this._demuxer = new FLVDemuxer(probeData, this._config);\n\n        if (!this._remuxer) {\n          this._remuxer = new MP4Remuxer(this._config);\n        }\n\n        var mds = this._mediaDataSource;\n\n        if (mds.duration != undefined && !isNaN(mds.duration)) {\n          this._demuxer.overridedDuration = mds.duration;\n        }\n\n        if (typeof mds.hasAudio === 'boolean') {\n          this._demuxer.overridedHasAudio = mds.hasAudio;\n        }\n\n        if (typeof mds.hasVideo === 'boolean') {\n          this._demuxer.overridedHasVideo = mds.hasVideo;\n        }\n\n        this._demuxer.timestampBase = mds.segments[this._currentSegmentIndex].timestampBase;\n        this._demuxer.onError = this._onDemuxException.bind(this);\n        this._demuxer.onMediaInfo = this._onMediaInfo.bind(this);\n        this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this);\n        this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this);\n\n        this._remuxer.bindDataSource(this._demuxer.bindDataSource(this._ioctl));\n\n        this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this);\n        this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this);\n        consumed = this._demuxer.parseChunks(data, byteStart);\n      } else {\n        probeData = null;\n        Log.e(this.TAG, 'Non-FLV, Unsupported media type!');\n        Promise.resolve().then(function () {\n          _this._internalAbort();\n        });\n\n        this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, DemuxErrors.FORMAT_UNSUPPORTED, 'Non-FLV, Unsupported media type');\n\n        consumed = 0;\n      }\n\n      return consumed;\n    }\n  }, {\n    key: \"_onMediaInfo\",\n    value: function _onMediaInfo(mediaInfo) {\n      var _this2 = this;\n\n      if (this._mediaInfo == null) {\n        // Store first segment's mediainfo as global mediaInfo\n        this._mediaInfo = Object.assign({}, mediaInfo);\n        this._mediaInfo.keyframesIndex = null;\n        this._mediaInfo.segments = [];\n        this._mediaInfo.segmentCount = this._mediaDataSource.segments.length;\n        Object.setPrototypeOf(this._mediaInfo, MediaInfo.prototype);\n      }\n\n      var segmentInfo = Object.assign({}, mediaInfo);\n      Object.setPrototypeOf(segmentInfo, MediaInfo.prototype);\n      this._mediaInfo.segments[this._currentSegmentIndex] = segmentInfo; // notify mediaInfo update\n\n      this._reportSegmentMediaInfo(this._currentSegmentIndex);\n\n      if (this._pendingSeekTime != null) {\n        Promise.resolve().then(function () {\n          var target = _this2._pendingSeekTime;\n          _this2._pendingSeekTime = null;\n\n          _this2.seek(target);\n        });\n      }\n    }\n  }, {\n    key: \"_onMetaDataArrived\",\n    value: function _onMetaDataArrived(metadata) {\n      this._emitter.emit(TransmuxingEvents.METADATA_ARRIVED, metadata);\n    }\n  }, {\n    key: \"_onScriptDataArrived\",\n    value: function _onScriptDataArrived(data) {\n      this._emitter.emit(TransmuxingEvents.SCRIPTDATA_ARRIVED, data);\n    }\n  }, {\n    key: \"_onIOSeeked\",\n    value: function _onIOSeeked() {\n      this._remuxer.insertDiscontinuity();\n    }\n  }, {\n    key: \"_onIOComplete\",\n    value: function _onIOComplete(extraData) {\n      var segmentIndex = extraData;\n      var nextSegmentIndex = segmentIndex + 1;\n\n      if (nextSegmentIndex < this._mediaDataSource.segments.length) {\n        this._internalAbort();\n\n        this._remuxer.flushStashedSamples();\n\n        this._loadSegment(nextSegmentIndex);\n      } else {\n        this._remuxer.flushStashedSamples();\n\n        this._emitter.emit(TransmuxingEvents.LOADING_COMPLETE);\n\n        this._disableStatisticsReporter();\n      }\n    }\n  }, {\n    key: \"_onIORedirect\",\n    value: function _onIORedirect(redirectedURL) {\n      var segmentIndex = this._ioctl.extraData;\n      this._mediaDataSource.segments[segmentIndex].redirectedURL = redirectedURL;\n    }\n  }, {\n    key: \"_onIORecoveredEarlyEof\",\n    value: function _onIORecoveredEarlyEof() {\n      this._emitter.emit(TransmuxingEvents.RECOVERED_EARLY_EOF);\n    }\n  }, {\n    key: \"_onIOException\",\n    value: function _onIOException(type, info) {\n      Log.e(this.TAG, \"IOException: type = \".concat(type, \", code = \").concat(info.code, \", msg = \").concat(info.msg));\n\n      this._emitter.emit(TransmuxingEvents.IO_ERROR, type, info);\n\n      this._disableStatisticsReporter();\n    }\n  }, {\n    key: \"_onDemuxException\",\n    value: function _onDemuxException(type, info) {\n      Log.e(this.TAG, \"DemuxException: type = \".concat(type, \", info = \").concat(info));\n\n      this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, type, info);\n    }\n  }, {\n    key: \"_onRemuxerInitSegmentArrival\",\n    value: function _onRemuxerInitSegmentArrival(type, initSegment) {\n      this._emitter.emit(TransmuxingEvents.INIT_SEGMENT, type, initSegment);\n    }\n  }, {\n    key: \"_onRemuxerMediaSegmentArrival\",\n    value: function _onRemuxerMediaSegmentArrival(type, mediaSegment) {\n      if (this._pendingSeekTime != null) {\n        // Media segments after new-segment cross-seeking should be dropped.\n        return;\n      }\n\n      this._emitter.emit(TransmuxingEvents.MEDIA_SEGMENT, type, mediaSegment); // Resolve pending seekPoint\n\n\n      if (this._pendingResolveSeekPoint != null && type === 'video') {\n        var syncPoints = mediaSegment.info.syncPoints;\n        var seekpoint = this._pendingResolveSeekPoint;\n        this._pendingResolveSeekPoint = null; // Safari: Pass PTS for recommend_seekpoint\n\n        if (Browser.safari && syncPoints.length > 0 && syncPoints[0].originalDts === seekpoint) {\n          seekpoint = syncPoints[0].pts;\n        } // else: use original DTS (keyframe.milliseconds)\n\n\n        this._emitter.emit(TransmuxingEvents.RECOMMEND_SEEKPOINT, seekpoint);\n      }\n    }\n  }, {\n    key: \"_enableStatisticsReporter\",\n    value: function _enableStatisticsReporter() {\n      if (this._statisticsReporter == null) {\n        this._statisticsReporter = self.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval);\n      }\n    }\n  }, {\n    key: \"_disableStatisticsReporter\",\n    value: function _disableStatisticsReporter() {\n      if (this._statisticsReporter) {\n        self.clearInterval(this._statisticsReporter);\n        this._statisticsReporter = null;\n      }\n    }\n  }, {\n    key: \"_reportSegmentMediaInfo\",\n    value: function _reportSegmentMediaInfo(segmentIndex) {\n      var segmentInfo = this._mediaInfo.segments[segmentIndex];\n      var exportInfo = Object.assign({}, segmentInfo);\n      exportInfo.duration = this._mediaInfo.duration;\n      exportInfo.segmentCount = this._mediaInfo.segmentCount;\n      delete exportInfo.segments;\n      delete exportInfo.keyframesIndex;\n\n      this._emitter.emit(TransmuxingEvents.MEDIA_INFO, exportInfo);\n    }\n  }, {\n    key: \"_reportStatisticsInfo\",\n    value: function _reportStatisticsInfo() {\n      var info = {};\n      info.url = this._ioctl.currentURL;\n      info.hasRedirect = this._ioctl.hasRedirect;\n\n      if (info.hasRedirect) {\n        info.redirectedURL = this._ioctl.currentRedirectedURL;\n      }\n\n      info.speed = this._ioctl.currentSpeed;\n      info.loaderType = this._ioctl.loaderType;\n      info.currentSegmentIndex = this._currentSegmentIndex;\n      info.totalSegmentCount = this._mediaDataSource.segments.length;\n\n      this._emitter.emit(TransmuxingEvents.STATISTICS_INFO, info);\n    }\n  }]);\n\n  return TransmuxingController;\n}();\n\nexport default TransmuxingController;","map":{"version":3,"sources":["D:/STREAMING_SITE/client/node_modules/flv.js/src/core/transmuxing-controller.js"],"names":["EventEmitter","Log","Browser","MediaInfo","FLVDemuxer","MP4Remuxer","DemuxErrors","IOController","TransmuxingEvents","LoaderStatus","LoaderErrors","TransmuxingController","mediaDataSource","config","TAG","_emitter","_config","segments","duration","filesize","url","cors","withCredentials","_mediaDataSource","_currentSegmentIndex","totalDuration","forEach","segment","timestampBase","referrerPolicy","isNaN","_mediaInfo","_demuxer","_remuxer","_ioctl","_pendingSeekTime","_pendingResolveSeekPoint","_statisticsReporter","_disableStatisticsReporter","destroy","removeAllListeners","event","listener","addListener","removeListener","_loadSegment","_enableStatisticsReporter","segmentIndex","optionalFrom","dataSource","ioctl","onError","_onIOException","bind","onSeeked","_onIOSeeked","onComplete","_onIOComplete","onRedirect","_onIORedirect","onRecoveredEarlyEof","_onIORecoveredEarlyEof","bindDataSource","onDataArrival","_onInitChunkArrival","open","_internalAbort","isWorking","pause","isPaused","resume","milliseconds","isSeekable","targetSegmentIndex","_searchSegmentIndexContains","segmentInfo","undefined","keyframe","getNearestKeyframe","seek","fileposition","targetSegmentInfo","insertDiscontinuity","resetMediaInfo","_reportSegmentMediaInfo","idx","length","i","data","byteStart","probeData","consumed","parseChunks","probe","match","mds","overridedDuration","hasAudio","overridedHasAudio","hasVideo","overridedHasVideo","_onDemuxException","onMediaInfo","_onMediaInfo","onMetaDataArrived","_onMetaDataArrived","onScriptDataArrived","_onScriptDataArrived","onInitSegment","_onRemuxerInitSegmentArrival","onMediaSegment","_onRemuxerMediaSegmentArrival","e","Promise","resolve","then","emit","DEMUX_ERROR","FORMAT_UNSUPPORTED","mediaInfo","Object","assign","keyframesIndex","segmentCount","setPrototypeOf","prototype","target","metadata","METADATA_ARRIVED","SCRIPTDATA_ARRIVED","extraData","nextSegmentIndex","flushStashedSamples","LOADING_COMPLETE","redirectedURL","RECOVERED_EARLY_EOF","type","info","code","msg","IO_ERROR","initSegment","INIT_SEGMENT","mediaSegment","MEDIA_SEGMENT","syncPoints","seekpoint","safari","originalDts","pts","RECOMMEND_SEEKPOINT","self","setInterval","_reportStatisticsInfo","statisticsInfoReportInterval","clearInterval","exportInfo","MEDIA_INFO","currentURL","hasRedirect","currentRedirectedURL","speed","currentSpeed","loaderType","currentSegmentIndex","totalSegmentCount","STATISTICS_INFO"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MediaInfo from './media-info.js';\nimport FLVDemuxer from '../demux/flv-demuxer.js';\nimport MP4Remuxer from '../remux/mp4-remuxer.js';\nimport DemuxErrors from '../demux/demux-errors.js';\nimport IOController from '../io/io-controller.js';\nimport TransmuxingEvents from './transmuxing-events.js';\nimport {LoaderStatus, LoaderErrors} from '../io/loader.js';\n\n// Transmuxing (IO, Demuxing, Remuxing) controller, with multipart support\nclass TransmuxingController {\n\n    constructor(mediaDataSource, config) {\n        this.TAG = 'TransmuxingController';\n        this._emitter = new EventEmitter();\n\n        this._config = config;\n\n        // treat single part media as multipart media, which has only one segment\n        if (!mediaDataSource.segments) {\n            mediaDataSource.segments = [{\n                duration: mediaDataSource.duration,\n                filesize: mediaDataSource.filesize,\n                url: mediaDataSource.url\n            }];\n        }\n\n        // fill in default IO params if not exists\n        if (typeof mediaDataSource.cors !== 'boolean') {\n            mediaDataSource.cors = true;\n        }\n        if (typeof mediaDataSource.withCredentials !== 'boolean') {\n            mediaDataSource.withCredentials = false;\n        }\n\n        this._mediaDataSource = mediaDataSource;\n        this._currentSegmentIndex = 0;\n        let totalDuration = 0;\n\n        this._mediaDataSource.segments.forEach((segment) => {\n            // timestampBase for each segment, and calculate total duration\n            segment.timestampBase = totalDuration;\n            totalDuration += segment.duration;\n            // params needed by IOController\n            segment.cors = mediaDataSource.cors;\n            segment.withCredentials = mediaDataSource.withCredentials;\n            // referrer policy control, if exist\n            if (config.referrerPolicy) {\n                segment.referrerPolicy = config.referrerPolicy;\n            }\n        });\n\n        if (!isNaN(totalDuration) && this._mediaDataSource.duration !== totalDuration) {\n            this._mediaDataSource.duration = totalDuration;\n        }\n\n        this._mediaInfo = null;\n        this._demuxer = null;\n        this._remuxer = null;\n        this._ioctl = null;\n\n        this._pendingSeekTime = null;\n        this._pendingResolveSeekPoint = null;\n\n        this._statisticsReporter = null;\n    }\n\n    destroy() {\n        this._mediaInfo = null;\n        this._mediaDataSource = null;\n\n        if (this._statisticsReporter) {\n            this._disableStatisticsReporter();\n        }\n        if (this._ioctl) {\n            this._ioctl.destroy();\n            this._ioctl = null;\n        }\n        if (this._demuxer) {\n            this._demuxer.destroy();\n            this._demuxer = null;\n        }\n        if (this._remuxer) {\n            this._remuxer.destroy();\n            this._remuxer = null;\n        }\n\n        this._emitter.removeAllListeners();\n        this._emitter = null;\n    }\n\n    on(event, listener) {\n        this._emitter.addListener(event, listener);\n    }\n\n    off(event, listener) {\n        this._emitter.removeListener(event, listener);\n    }\n\n    start() {\n        this._loadSegment(0);\n        this._enableStatisticsReporter();\n    }\n\n    _loadSegment(segmentIndex, optionalFrom) {\n        this._currentSegmentIndex = segmentIndex;\n        let dataSource = this._mediaDataSource.segments[segmentIndex];\n\n        let ioctl = this._ioctl = new IOController(dataSource, this._config, segmentIndex);\n        ioctl.onError = this._onIOException.bind(this);\n        ioctl.onSeeked = this._onIOSeeked.bind(this);\n        ioctl.onComplete = this._onIOComplete.bind(this);\n        ioctl.onRedirect = this._onIORedirect.bind(this);\n        ioctl.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this);\n\n        if (optionalFrom) {\n            this._demuxer.bindDataSource(this._ioctl);\n        } else {\n            ioctl.onDataArrival = this._onInitChunkArrival.bind(this);\n        }\n\n        ioctl.open(optionalFrom);\n    }\n\n    stop() {\n        this._internalAbort();\n        this._disableStatisticsReporter();\n    }\n\n    _internalAbort() {\n        if (this._ioctl) {\n            this._ioctl.destroy();\n            this._ioctl = null;\n        }\n    }\n\n    pause() {  // take a rest\n        if (this._ioctl && this._ioctl.isWorking()) {\n            this._ioctl.pause();\n            this._disableStatisticsReporter();\n        }\n    }\n\n    resume() {\n        if (this._ioctl && this._ioctl.isPaused()) {\n            this._ioctl.resume();\n            this._enableStatisticsReporter();\n        }\n    }\n\n    seek(milliseconds) {\n        if (this._mediaInfo == null || !this._mediaInfo.isSeekable()) {\n            return;\n        }\n\n        let targetSegmentIndex = this._searchSegmentIndexContains(milliseconds);\n\n        if (targetSegmentIndex === this._currentSegmentIndex) {\n            // intra-segment seeking\n            let segmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n            if (segmentInfo == undefined) {\n                // current segment loading started, but mediainfo hasn't received yet\n                // wait for the metadata loaded, then seek to expected position\n                this._pendingSeekTime = milliseconds;\n            } else {\n                let keyframe = segmentInfo.getNearestKeyframe(milliseconds);\n                this._remuxer.seek(keyframe.milliseconds);\n                this._ioctl.seek(keyframe.fileposition);\n                // Will be resolved in _onRemuxerMediaSegmentArrival()\n                this._pendingResolveSeekPoint = keyframe.milliseconds;\n            }\n        } else {\n            // cross-segment seeking\n            let targetSegmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n            if (targetSegmentInfo == undefined) {\n                // target segment hasn't been loaded. We need metadata then seek to expected time\n                this._pendingSeekTime = milliseconds;\n                this._internalAbort();\n                this._remuxer.seek();\n                this._remuxer.insertDiscontinuity();\n                this._loadSegment(targetSegmentIndex);\n                // Here we wait for the metadata loaded, then seek to expected position\n            } else {\n                // We have target segment's metadata, direct seek to target position\n                let keyframe = targetSegmentInfo.getNearestKeyframe(milliseconds);\n                this._internalAbort();\n                this._remuxer.seek(milliseconds);\n                this._remuxer.insertDiscontinuity();\n                this._demuxer.resetMediaInfo();\n                this._demuxer.timestampBase = this._mediaDataSource.segments[targetSegmentIndex].timestampBase;\n                this._loadSegment(targetSegmentIndex, keyframe.fileposition);\n                this._pendingResolveSeekPoint = keyframe.milliseconds;\n                this._reportSegmentMediaInfo(targetSegmentIndex);\n            }\n        }\n\n        this._enableStatisticsReporter();\n    }\n\n    _searchSegmentIndexContains(milliseconds) {\n        let segments = this._mediaDataSource.segments;\n        let idx = segments.length - 1;\n\n        for (let i = 0; i < segments.length; i++) {\n            if (milliseconds < segments[i].timestampBase) {\n                idx = i - 1;\n                break;\n            }\n        }\n        return idx;\n    }\n\n    _onInitChunkArrival(data, byteStart) {\n        let probeData = null;\n        let consumed = 0;\n\n        if (byteStart > 0) {\n            // IOController seeked immediately after opened, byteStart > 0 callback may received\n            this._demuxer.bindDataSource(this._ioctl);\n            this._demuxer.timestampBase = this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase;\n\n            consumed = this._demuxer.parseChunks(data, byteStart);\n        } else if ((probeData = FLVDemuxer.probe(data)).match) {\n            // Always create new FLVDemuxer\n            this._demuxer = new FLVDemuxer(probeData, this._config);\n\n            if (!this._remuxer) {\n                this._remuxer = new MP4Remuxer(this._config);\n            }\n\n            let mds = this._mediaDataSource;\n            if (mds.duration != undefined && !isNaN(mds.duration)) {\n                this._demuxer.overridedDuration = mds.duration;\n            }\n            if (typeof mds.hasAudio === 'boolean') {\n                this._demuxer.overridedHasAudio = mds.hasAudio;\n            }\n            if (typeof mds.hasVideo === 'boolean') {\n                this._demuxer.overridedHasVideo = mds.hasVideo;\n            }\n\n            this._demuxer.timestampBase = mds.segments[this._currentSegmentIndex].timestampBase;\n\n            this._demuxer.onError = this._onDemuxException.bind(this);\n            this._demuxer.onMediaInfo = this._onMediaInfo.bind(this);\n            this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this);\n            this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this);\n\n            this._remuxer.bindDataSource(this._demuxer\n                         .bindDataSource(this._ioctl\n            ));\n\n            this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this);\n            this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this);\n\n            consumed = this._demuxer.parseChunks(data, byteStart);\n        } else {\n            probeData = null;\n            Log.e(this.TAG, 'Non-FLV, Unsupported media type!');\n            Promise.resolve().then(() => {\n                this._internalAbort();\n            });\n            this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, DemuxErrors.FORMAT_UNSUPPORTED, 'Non-FLV, Unsupported media type');\n\n            consumed = 0;\n        }\n\n        return consumed;\n    }\n\n    _onMediaInfo(mediaInfo) {\n        if (this._mediaInfo == null) {\n            // Store first segment's mediainfo as global mediaInfo\n            this._mediaInfo = Object.assign({}, mediaInfo);\n            this._mediaInfo.keyframesIndex = null;\n            this._mediaInfo.segments = [];\n            this._mediaInfo.segmentCount = this._mediaDataSource.segments.length;\n            Object.setPrototypeOf(this._mediaInfo, MediaInfo.prototype);\n        }\n\n        let segmentInfo = Object.assign({}, mediaInfo);\n        Object.setPrototypeOf(segmentInfo, MediaInfo.prototype);\n        this._mediaInfo.segments[this._currentSegmentIndex] = segmentInfo;\n\n        // notify mediaInfo update\n        this._reportSegmentMediaInfo(this._currentSegmentIndex);\n\n        if (this._pendingSeekTime != null) {\n            Promise.resolve().then(() => {\n                let target = this._pendingSeekTime;\n                this._pendingSeekTime = null;\n                this.seek(target);\n            });\n        }\n    }\n\n    _onMetaDataArrived(metadata) {\n        this._emitter.emit(TransmuxingEvents.METADATA_ARRIVED, metadata);\n    }\n\n    _onScriptDataArrived(data) {\n        this._emitter.emit(TransmuxingEvents.SCRIPTDATA_ARRIVED, data);\n    }\n\n    _onIOSeeked() {\n        this._remuxer.insertDiscontinuity();\n    }\n\n    _onIOComplete(extraData) {\n        let segmentIndex = extraData;\n        let nextSegmentIndex = segmentIndex + 1;\n\n        if (nextSegmentIndex < this._mediaDataSource.segments.length) {\n            this._internalAbort();\n            this._remuxer.flushStashedSamples();\n            this._loadSegment(nextSegmentIndex);\n        } else {\n            this._remuxer.flushStashedSamples();\n            this._emitter.emit(TransmuxingEvents.LOADING_COMPLETE);\n            this._disableStatisticsReporter();\n        }\n    }\n\n    _onIORedirect(redirectedURL) {\n        let segmentIndex = this._ioctl.extraData;\n        this._mediaDataSource.segments[segmentIndex].redirectedURL = redirectedURL;\n    }\n\n    _onIORecoveredEarlyEof() {\n        this._emitter.emit(TransmuxingEvents.RECOVERED_EARLY_EOF);\n    }\n\n    _onIOException(type, info) {\n        Log.e(this.TAG, `IOException: type = ${type}, code = ${info.code}, msg = ${info.msg}`);\n        this._emitter.emit(TransmuxingEvents.IO_ERROR, type, info);\n        this._disableStatisticsReporter();\n    }\n\n    _onDemuxException(type, info) {\n        Log.e(this.TAG, `DemuxException: type = ${type}, info = ${info}`);\n        this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, type, info);\n    }\n\n    _onRemuxerInitSegmentArrival(type, initSegment) {\n        this._emitter.emit(TransmuxingEvents.INIT_SEGMENT, type, initSegment);\n    }\n\n    _onRemuxerMediaSegmentArrival(type, mediaSegment) {\n        if (this._pendingSeekTime != null) {\n            // Media segments after new-segment cross-seeking should be dropped.\n            return;\n        }\n        this._emitter.emit(TransmuxingEvents.MEDIA_SEGMENT, type, mediaSegment);\n\n        // Resolve pending seekPoint\n        if (this._pendingResolveSeekPoint != null && type === 'video') {\n            let syncPoints = mediaSegment.info.syncPoints;\n            let seekpoint = this._pendingResolveSeekPoint;\n            this._pendingResolveSeekPoint = null;\n\n            // Safari: Pass PTS for recommend_seekpoint\n            if (Browser.safari && syncPoints.length > 0 && syncPoints[0].originalDts === seekpoint) {\n                seekpoint = syncPoints[0].pts;\n            }\n            // else: use original DTS (keyframe.milliseconds)\n\n            this._emitter.emit(TransmuxingEvents.RECOMMEND_SEEKPOINT, seekpoint);\n        }\n    }\n\n    _enableStatisticsReporter() {\n        if (this._statisticsReporter == null) {\n            this._statisticsReporter = self.setInterval(\n                this._reportStatisticsInfo.bind(this),\n            this._config.statisticsInfoReportInterval);\n        }\n    }\n\n    _disableStatisticsReporter() {\n        if (this._statisticsReporter) {\n            self.clearInterval(this._statisticsReporter);\n            this._statisticsReporter = null;\n        }\n    }\n\n    _reportSegmentMediaInfo(segmentIndex) {\n        let segmentInfo = this._mediaInfo.segments[segmentIndex];\n        let exportInfo = Object.assign({}, segmentInfo);\n\n        exportInfo.duration = this._mediaInfo.duration;\n        exportInfo.segmentCount = this._mediaInfo.segmentCount;\n        delete exportInfo.segments;\n        delete exportInfo.keyframesIndex;\n\n        this._emitter.emit(TransmuxingEvents.MEDIA_INFO, exportInfo);\n    }\n\n    _reportStatisticsInfo() {\n        let info = {};\n\n        info.url = this._ioctl.currentURL;\n        info.hasRedirect = this._ioctl.hasRedirect;\n        if (info.hasRedirect) {\n            info.redirectedURL = this._ioctl.currentRedirectedURL;\n        }\n\n        info.speed = this._ioctl.currentSpeed;\n        info.loaderType = this._ioctl.loaderType;\n        info.currentSegmentIndex = this._currentSegmentIndex;\n        info.totalSegmentCount = this._mediaDataSource.segments.length;\n\n        this._emitter.emit(TransmuxingEvents.STATISTICS_INFO, info);\n    }\n\n}\n\nexport default TransmuxingController;"]},"metadata":{},"sourceType":"module"}