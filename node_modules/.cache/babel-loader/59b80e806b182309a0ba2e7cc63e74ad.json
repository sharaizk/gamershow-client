{"ast":null,"code":"import _classCallCheck from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MSEEvents from './mse-events.js';\nimport { SampleInfo, IDRSampleList } from './media-segment-info.js';\nimport { IllegalStateException } from '../utils/exception.js'; // Media Source Extensions controller\n\nvar MSEController = /*#__PURE__*/function () {\n  function MSEController(config) {\n    _classCallCheck(this, MSEController);\n\n    this.TAG = 'MSEController';\n    this._config = config;\n    this._emitter = new EventEmitter();\n\n    if (this._config.isLive && this._config.autoCleanupSourceBuffer == undefined) {\n      // For live stream, do auto cleanup by default\n      this._config.autoCleanupSourceBuffer = true;\n    }\n\n    this.e = {\n      onSourceOpen: this._onSourceOpen.bind(this),\n      onSourceEnded: this._onSourceEnded.bind(this),\n      onSourceClose: this._onSourceClose.bind(this),\n      onSourceBufferError: this._onSourceBufferError.bind(this),\n      onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)\n    };\n    this._mediaSource = null;\n    this._mediaSourceObjectURL = null;\n    this._mediaElement = null;\n    this._isBufferFull = false;\n    this._hasPendingEos = false;\n    this._requireSetMediaDuration = false;\n    this._pendingMediaDuration = 0;\n    this._pendingSourceBufferInit = [];\n    this._mimeTypes = {\n      video: null,\n      audio: null\n    };\n    this._sourceBuffers = {\n      video: null,\n      audio: null\n    };\n    this._lastInitSegments = {\n      video: null,\n      audio: null\n    };\n    this._pendingSegments = {\n      video: [],\n      audio: []\n    };\n    this._pendingRemoveRanges = {\n      video: [],\n      audio: []\n    };\n    this._idrList = new IDRSampleList();\n  }\n\n  _createClass(MSEController, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._mediaElement || this._mediaSource) {\n        this.detachMediaElement();\n      }\n\n      this.e = null;\n\n      this._emitter.removeAllListeners();\n\n      this._emitter = null;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this._emitter.addListener(event, listener);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this._emitter.removeListener(event, listener);\n    }\n  }, {\n    key: \"attachMediaElement\",\n    value: function attachMediaElement(mediaElement) {\n      if (this._mediaSource) {\n        throw new IllegalStateException('MediaSource has been attached to an HTMLMediaElement!');\n      }\n\n      var ms = this._mediaSource = new window.MediaSource();\n      ms.addEventListener('sourceopen', this.e.onSourceOpen);\n      ms.addEventListener('sourceended', this.e.onSourceEnded);\n      ms.addEventListener('sourceclose', this.e.onSourceClose);\n      this._mediaElement = mediaElement;\n      this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource);\n      mediaElement.src = this._mediaSourceObjectURL;\n    }\n  }, {\n    key: \"detachMediaElement\",\n    value: function detachMediaElement() {\n      if (this._mediaSource) {\n        var ms = this._mediaSource;\n\n        for (var type in this._sourceBuffers) {\n          // pending segments should be discard\n          var ps = this._pendingSegments[type];\n          ps.splice(0, ps.length);\n          this._pendingSegments[type] = null;\n          this._pendingRemoveRanges[type] = null;\n          this._lastInitSegments[type] = null; // remove all sourcebuffers\n\n          var sb = this._sourceBuffers[type];\n\n          if (sb) {\n            if (ms.readyState !== 'closed') {\n              // ms edge can throw an error: Unexpected call to method or property access\n              try {\n                ms.removeSourceBuffer(sb);\n              } catch (error) {\n                Log.e(this.TAG, error.message);\n              }\n\n              sb.removeEventListener('error', this.e.onSourceBufferError);\n              sb.removeEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n            }\n\n            this._mimeTypes[type] = null;\n            this._sourceBuffers[type] = null;\n          }\n        }\n\n        if (ms.readyState === 'open') {\n          try {\n            ms.endOfStream();\n          } catch (error) {\n            Log.e(this.TAG, error.message);\n          }\n        }\n\n        ms.removeEventListener('sourceopen', this.e.onSourceOpen);\n        ms.removeEventListener('sourceended', this.e.onSourceEnded);\n        ms.removeEventListener('sourceclose', this.e.onSourceClose);\n        this._pendingSourceBufferInit = [];\n        this._isBufferFull = false;\n\n        this._idrList.clear();\n\n        this._mediaSource = null;\n      }\n\n      if (this._mediaElement) {\n        this._mediaElement.src = '';\n\n        this._mediaElement.removeAttribute('src');\n\n        this._mediaElement = null;\n      }\n\n      if (this._mediaSourceObjectURL) {\n        window.URL.revokeObjectURL(this._mediaSourceObjectURL);\n        this._mediaSourceObjectURL = null;\n      }\n    }\n  }, {\n    key: \"appendInitSegment\",\n    value: function appendInitSegment(initSegment, deferred) {\n      if (!this._mediaSource || this._mediaSource.readyState !== 'open') {\n        // sourcebuffer creation requires mediaSource.readyState === 'open'\n        // so we defer the sourcebuffer creation, until sourceopen event triggered\n        this._pendingSourceBufferInit.push(initSegment); // make sure that this InitSegment is in the front of pending segments queue\n\n\n        this._pendingSegments[initSegment.type].push(initSegment);\n\n        return;\n      }\n\n      var is = initSegment;\n      var mimeType = \"\".concat(is.container);\n\n      if (is.codec && is.codec.length > 0) {\n        mimeType += \";codecs=\".concat(is.codec);\n      }\n\n      var firstInitSegment = false;\n      Log.v(this.TAG, 'Received Initialization Segment, mimeType: ' + mimeType);\n      this._lastInitSegments[is.type] = is;\n\n      if (mimeType !== this._mimeTypes[is.type]) {\n        if (!this._mimeTypes[is.type]) {\n          // empty, first chance create sourcebuffer\n          firstInitSegment = true;\n\n          try {\n            var sb = this._sourceBuffers[is.type] = this._mediaSource.addSourceBuffer(mimeType);\n\n            sb.addEventListener('error', this.e.onSourceBufferError);\n            sb.addEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n          } catch (error) {\n            Log.e(this.TAG, error.message);\n\n            this._emitter.emit(MSEEvents.ERROR, {\n              code: error.code,\n              msg: error.message\n            });\n\n            return;\n          }\n        } else {\n          Log.v(this.TAG, \"Notice: \".concat(is.type, \" mimeType changed, origin: \").concat(this._mimeTypes[is.type], \", target: \").concat(mimeType));\n        }\n\n        this._mimeTypes[is.type] = mimeType;\n      }\n\n      if (!deferred) {\n        // deferred means this InitSegment has been pushed to pendingSegments queue\n        this._pendingSegments[is.type].push(is);\n      }\n\n      if (!firstInitSegment) {\n        // append immediately only if init segment in subsequence\n        if (this._sourceBuffers[is.type] && !this._sourceBuffers[is.type].updating) {\n          this._doAppendSegments();\n        }\n      }\n\n      if (Browser.safari && is.container === 'audio/mpeg' && is.mediaDuration > 0) {\n        // 'audio/mpeg' track under Safari may cause MediaElement's duration to be NaN\n        // Manually correct MediaSource.duration to make progress bar seekable, and report right duration\n        this._requireSetMediaDuration = true;\n        this._pendingMediaDuration = is.mediaDuration / 1000; // in seconds\n\n        this._updateMediaSourceDuration();\n      }\n    }\n  }, {\n    key: \"appendMediaSegment\",\n    value: function appendMediaSegment(mediaSegment) {\n      var ms = mediaSegment;\n\n      this._pendingSegments[ms.type].push(ms);\n\n      if (this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer()) {\n        this._doCleanupSourceBuffer();\n      }\n\n      var sb = this._sourceBuffers[ms.type];\n\n      if (sb && !sb.updating && !this._hasPendingRemoveRanges()) {\n        this._doAppendSegments();\n      }\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(seconds) {\n      // remove all appended buffers\n      for (var type in this._sourceBuffers) {\n        if (!this._sourceBuffers[type]) {\n          continue;\n        } // abort current buffer append algorithm\n\n\n        var sb = this._sourceBuffers[type];\n\n        if (this._mediaSource.readyState === 'open') {\n          try {\n            // If range removal algorithm is running, InvalidStateError will be throwed\n            // Ignore it.\n            sb.abort();\n          } catch (error) {\n            Log.e(this.TAG, error.message);\n          }\n        } // IDRList should be clear\n\n\n        this._idrList.clear(); // pending segments should be discard\n\n\n        var ps = this._pendingSegments[type];\n        ps.splice(0, ps.length);\n\n        if (this._mediaSource.readyState === 'closed') {\n          // Parent MediaSource object has been detached from HTMLMediaElement\n          continue;\n        } // record ranges to be remove from SourceBuffer\n\n\n        for (var i = 0; i < sb.buffered.length; i++) {\n          var start = sb.buffered.start(i);\n          var end = sb.buffered.end(i);\n\n          this._pendingRemoveRanges[type].push({\n            start: start,\n            end: end\n          });\n        } // if sb is not updating, let's remove ranges now!\n\n\n        if (!sb.updating) {\n          this._doRemoveRanges();\n        } // Safari 10 may get InvalidStateError in the later appendBuffer() after SourceBuffer.remove() call\n        // Internal parser's state may be invalid at this time. Re-append last InitSegment to workaround.\n        // Related issue: https://bugs.webkit.org/show_bug.cgi?id=159230\n\n\n        if (Browser.safari) {\n          var lastInitSegment = this._lastInitSegments[type];\n\n          if (lastInitSegment) {\n            this._pendingSegments[type].push(lastInitSegment);\n\n            if (!sb.updating) {\n              this._doAppendSegments();\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"endOfStream\",\n    value: function endOfStream() {\n      var ms = this._mediaSource;\n      var sb = this._sourceBuffers;\n\n      if (!ms || ms.readyState !== 'open') {\n        if (ms && ms.readyState === 'closed' && this._hasPendingSegments()) {\n          // If MediaSource hasn't turned into open state, and there're pending segments\n          // Mark pending endOfStream, defer call until all pending segments appended complete\n          this._hasPendingEos = true;\n        }\n\n        return;\n      }\n\n      if (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n        // If any sourcebuffer is updating, defer endOfStream operation\n        // See _onSourceBufferUpdateEnd()\n        this._hasPendingEos = true;\n      } else {\n        this._hasPendingEos = false; // Notify media data loading complete\n        // This is helpful for correcting total duration to match last media segment\n        // Otherwise MediaElement's ended event may not be triggered\n\n        ms.endOfStream();\n      }\n    }\n  }, {\n    key: \"getNearestKeyframe\",\n    value: function getNearestKeyframe(dts) {\n      return this._idrList.getLastSyncPointBeforeDts(dts);\n    }\n  }, {\n    key: \"_needCleanupSourceBuffer\",\n    value: function _needCleanupSourceBuffer() {\n      if (!this._config.autoCleanupSourceBuffer) {\n        return false;\n      }\n\n      var currentTime = this._mediaElement.currentTime;\n\n      for (var type in this._sourceBuffers) {\n        var sb = this._sourceBuffers[type];\n\n        if (sb) {\n          var buffered = sb.buffered;\n\n          if (buffered.length >= 1) {\n            if (currentTime - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_doCleanupSourceBuffer\",\n    value: function _doCleanupSourceBuffer() {\n      var currentTime = this._mediaElement.currentTime;\n\n      for (var type in this._sourceBuffers) {\n        var sb = this._sourceBuffers[type];\n\n        if (sb) {\n          var buffered = sb.buffered;\n          var doRemove = false;\n\n          for (var i = 0; i < buffered.length; i++) {\n            var start = buffered.start(i);\n            var end = buffered.end(i);\n\n            if (start <= currentTime && currentTime < end + 3) {\n              // padding 3 seconds\n              if (currentTime - start >= this._config.autoCleanupMaxBackwardDuration) {\n                doRemove = true;\n                var removeEnd = currentTime - this._config.autoCleanupMinBackwardDuration;\n\n                this._pendingRemoveRanges[type].push({\n                  start: start,\n                  end: removeEnd\n                });\n              }\n            } else if (end < currentTime) {\n              doRemove = true;\n\n              this._pendingRemoveRanges[type].push({\n                start: start,\n                end: end\n              });\n            }\n          }\n\n          if (doRemove && !sb.updating) {\n            this._doRemoveRanges();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateMediaSourceDuration\",\n    value: function _updateMediaSourceDuration() {\n      var sb = this._sourceBuffers;\n\n      if (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== 'open') {\n        return;\n      }\n\n      if (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n        return;\n      }\n\n      var current = this._mediaSource.duration;\n      var target = this._pendingMediaDuration;\n\n      if (target > 0 && (isNaN(current) || target > current)) {\n        Log.v(this.TAG, \"Update MediaSource duration from \".concat(current, \" to \").concat(target));\n        this._mediaSource.duration = target;\n      }\n\n      this._requireSetMediaDuration = false;\n      this._pendingMediaDuration = 0;\n    }\n  }, {\n    key: \"_doRemoveRanges\",\n    value: function _doRemoveRanges() {\n      for (var type in this._pendingRemoveRanges) {\n        if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n          continue;\n        }\n\n        var sb = this._sourceBuffers[type];\n        var ranges = this._pendingRemoveRanges[type];\n\n        while (ranges.length && !sb.updating) {\n          var range = ranges.shift();\n          sb.remove(range.start, range.end);\n        }\n      }\n    }\n  }, {\n    key: \"_doAppendSegments\",\n    value: function _doAppendSegments() {\n      var pendingSegments = this._pendingSegments;\n\n      for (var type in pendingSegments) {\n        if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n          continue;\n        }\n\n        if (pendingSegments[type].length > 0) {\n          var segment = pendingSegments[type].shift();\n\n          if (segment.timestampOffset) {\n            // For MPEG audio stream in MSE, if unbuffered-seeking occurred\n            // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n            var currentOffset = this._sourceBuffers[type].timestampOffset;\n            var targetOffset = segment.timestampOffset / 1000; // in seconds\n\n            var delta = Math.abs(currentOffset - targetOffset);\n\n            if (delta > 0.1) {\n              // If time delta > 100ms\n              Log.v(this.TAG, \"Update MPEG audio timestampOffset from \".concat(currentOffset, \" to \").concat(targetOffset));\n              this._sourceBuffers[type].timestampOffset = targetOffset;\n            }\n\n            delete segment.timestampOffset;\n          }\n\n          if (!segment.data || segment.data.byteLength === 0) {\n            // Ignore empty buffer\n            continue;\n          }\n\n          try {\n            this._sourceBuffers[type].appendBuffer(segment.data);\n\n            this._isBufferFull = false;\n\n            if (type === 'video' && segment.hasOwnProperty('info')) {\n              this._idrList.appendArray(segment.info.syncPoints);\n            }\n          } catch (error) {\n            this._pendingSegments[type].unshift(segment);\n\n            if (error.code === 22) {\n              // QuotaExceededError\n\n              /* Notice that FireFox may not throw QuotaExceededError if SourceBuffer is full\n               * Currently we can only do lazy-load to avoid SourceBuffer become scattered.\n               * SourceBuffer eviction policy may be changed in future version of FireFox.\n               *\n               * Related issues:\n               * https://bugzilla.mozilla.org/show_bug.cgi?id=1279885\n               * https://bugzilla.mozilla.org/show_bug.cgi?id=1280023\n               */\n              // report buffer full, abort network IO\n              if (!this._isBufferFull) {\n                this._emitter.emit(MSEEvents.BUFFER_FULL);\n              }\n\n              this._isBufferFull = true;\n            } else {\n              Log.e(this.TAG, error.message);\n\n              this._emitter.emit(MSEEvents.ERROR, {\n                code: error.code,\n                msg: error.message\n              });\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_onSourceOpen\",\n    value: function _onSourceOpen() {\n      Log.v(this.TAG, 'MediaSource onSourceOpen');\n\n      this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen); // deferred sourcebuffer creation / initialization\n\n\n      if (this._pendingSourceBufferInit.length > 0) {\n        var pendings = this._pendingSourceBufferInit;\n\n        while (pendings.length) {\n          var segment = pendings.shift();\n          this.appendInitSegment(segment, true);\n        }\n      } // there may be some pending media segments, append them\n\n\n      if (this._hasPendingSegments()) {\n        this._doAppendSegments();\n      }\n\n      this._emitter.emit(MSEEvents.SOURCE_OPEN);\n    }\n  }, {\n    key: \"_onSourceEnded\",\n    value: function _onSourceEnded() {\n      // fired on endOfStream\n      Log.v(this.TAG, 'MediaSource onSourceEnded');\n    }\n  }, {\n    key: \"_onSourceClose\",\n    value: function _onSourceClose() {\n      // fired on detaching from media element\n      Log.v(this.TAG, 'MediaSource onSourceClose');\n\n      if (this._mediaSource && this.e != null) {\n        this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n\n        this._mediaSource.removeEventListener('sourceended', this.e.onSourceEnded);\n\n        this._mediaSource.removeEventListener('sourceclose', this.e.onSourceClose);\n      }\n    }\n  }, {\n    key: \"_hasPendingSegments\",\n    value: function _hasPendingSegments() {\n      var ps = this._pendingSegments;\n      return ps.video.length > 0 || ps.audio.length > 0;\n    }\n  }, {\n    key: \"_hasPendingRemoveRanges\",\n    value: function _hasPendingRemoveRanges() {\n      var prr = this._pendingRemoveRanges;\n      return prr.video.length > 0 || prr.audio.length > 0;\n    }\n  }, {\n    key: \"_onSourceBufferUpdateEnd\",\n    value: function _onSourceBufferUpdateEnd() {\n      if (this._requireSetMediaDuration) {\n        this._updateMediaSourceDuration();\n      } else if (this._hasPendingRemoveRanges()) {\n        this._doRemoveRanges();\n      } else if (this._hasPendingSegments()) {\n        this._doAppendSegments();\n      } else if (this._hasPendingEos) {\n        this.endOfStream();\n      }\n\n      this._emitter.emit(MSEEvents.UPDATE_END);\n    }\n  }, {\n    key: \"_onSourceBufferError\",\n    value: function _onSourceBufferError(e) {\n      Log.e(this.TAG, \"SourceBuffer Error: \".concat(e)); // this error might not always be fatal, just ignore it\n    }\n  }]);\n\n  return MSEController;\n}();\n\nexport default MSEController;","map":{"version":3,"sources":["D:/STREAMING_SITE/client/node_modules/flv.js/src/core/mse-controller.js"],"names":["EventEmitter","Log","Browser","MSEEvents","SampleInfo","IDRSampleList","IllegalStateException","MSEController","config","TAG","_config","_emitter","isLive","autoCleanupSourceBuffer","undefined","e","onSourceOpen","_onSourceOpen","bind","onSourceEnded","_onSourceEnded","onSourceClose","_onSourceClose","onSourceBufferError","_onSourceBufferError","onSourceBufferUpdateEnd","_onSourceBufferUpdateEnd","_mediaSource","_mediaSourceObjectURL","_mediaElement","_isBufferFull","_hasPendingEos","_requireSetMediaDuration","_pendingMediaDuration","_pendingSourceBufferInit","_mimeTypes","video","audio","_sourceBuffers","_lastInitSegments","_pendingSegments","_pendingRemoveRanges","_idrList","detachMediaElement","removeAllListeners","event","listener","addListener","removeListener","mediaElement","ms","window","MediaSource","addEventListener","URL","createObjectURL","src","type","ps","splice","length","sb","readyState","removeSourceBuffer","error","message","removeEventListener","endOfStream","clear","removeAttribute","revokeObjectURL","initSegment","deferred","push","is","mimeType","container","codec","firstInitSegment","v","addSourceBuffer","emit","ERROR","code","msg","updating","_doAppendSegments","safari","mediaDuration","_updateMediaSourceDuration","mediaSegment","_needCleanupSourceBuffer","_doCleanupSourceBuffer","_hasPendingRemoveRanges","seconds","abort","i","buffered","start","end","_doRemoveRanges","lastInitSegment","_hasPendingSegments","dts","getLastSyncPointBeforeDts","currentTime","autoCleanupMaxBackwardDuration","doRemove","removeEnd","autoCleanupMinBackwardDuration","current","duration","target","isNaN","ranges","range","shift","remove","pendingSegments","segment","timestampOffset","currentOffset","targetOffset","delta","Math","abs","data","byteLength","appendBuffer","hasOwnProperty","appendArray","info","syncPoints","unshift","BUFFER_FULL","pendings","appendInitSegment","SOURCE_OPEN","prr","UPDATE_END"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MSEEvents from './mse-events.js';\nimport {SampleInfo, IDRSampleList} from './media-segment-info.js';\nimport {IllegalStateException} from '../utils/exception.js';\n\n// Media Source Extensions controller\nclass MSEController {\n\n    constructor(config) {\n        this.TAG = 'MSEController';\n\n        this._config = config;\n        this._emitter = new EventEmitter();\n\n        if (this._config.isLive && this._config.autoCleanupSourceBuffer == undefined) {\n            // For live stream, do auto cleanup by default\n            this._config.autoCleanupSourceBuffer = true;\n        }\n\n        this.e = {\n            onSourceOpen: this._onSourceOpen.bind(this),\n            onSourceEnded: this._onSourceEnded.bind(this),\n            onSourceClose: this._onSourceClose.bind(this),\n            onSourceBufferError: this._onSourceBufferError.bind(this),\n            onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)\n        };\n\n        this._mediaSource = null;\n        this._mediaSourceObjectURL = null;\n        this._mediaElement = null;\n\n        this._isBufferFull = false;\n        this._hasPendingEos = false;\n\n        this._requireSetMediaDuration = false;\n        this._pendingMediaDuration = 0;\n\n        this._pendingSourceBufferInit = [];\n        this._mimeTypes = {\n            video: null,\n            audio: null\n        };\n        this._sourceBuffers = {\n            video: null,\n            audio: null\n        };\n        this._lastInitSegments = {\n            video: null,\n            audio: null\n        };\n        this._pendingSegments = {\n            video: [],\n            audio: []\n        };\n        this._pendingRemoveRanges = {\n            video: [],\n            audio: []\n        };\n        this._idrList = new IDRSampleList();\n    }\n\n    destroy() {\n        if (this._mediaElement || this._mediaSource) {\n            this.detachMediaElement();\n        }\n        this.e = null;\n        this._emitter.removeAllListeners();\n        this._emitter = null;\n    }\n\n    on(event, listener) {\n        this._emitter.addListener(event, listener);\n    }\n\n    off(event, listener) {\n        this._emitter.removeListener(event, listener);\n    }\n\n    attachMediaElement(mediaElement) {\n        if (this._mediaSource) {\n            throw new IllegalStateException('MediaSource has been attached to an HTMLMediaElement!');\n        }\n        let ms = this._mediaSource = new window.MediaSource();\n        ms.addEventListener('sourceopen', this.e.onSourceOpen);\n        ms.addEventListener('sourceended', this.e.onSourceEnded);\n        ms.addEventListener('sourceclose', this.e.onSourceClose);\n\n        this._mediaElement = mediaElement;\n        this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource);\n        mediaElement.src = this._mediaSourceObjectURL;\n    }\n\n    detachMediaElement() {\n        if (this._mediaSource) {\n            let ms = this._mediaSource;\n            for (let type in this._sourceBuffers) {\n                // pending segments should be discard\n                let ps = this._pendingSegments[type];\n                ps.splice(0, ps.length);\n                this._pendingSegments[type] = null;\n                this._pendingRemoveRanges[type] = null;\n                this._lastInitSegments[type] = null;\n\n                // remove all sourcebuffers\n                let sb = this._sourceBuffers[type];\n                if (sb) {\n                    if (ms.readyState !== 'closed') {\n                        // ms edge can throw an error: Unexpected call to method or property access\n                        try {\n                            ms.removeSourceBuffer(sb);\n                        } catch (error) {\n                            Log.e(this.TAG, error.message);\n                        }\n                        sb.removeEventListener('error', this.e.onSourceBufferError);\n                        sb.removeEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n                    }\n                    this._mimeTypes[type] = null;\n                    this._sourceBuffers[type] = null;\n                }\n            }\n            if (ms.readyState === 'open') {\n                try {\n                    ms.endOfStream();\n                } catch (error) {\n                    Log.e(this.TAG, error.message);\n                }\n            }\n            ms.removeEventListener('sourceopen', this.e.onSourceOpen);\n            ms.removeEventListener('sourceended', this.e.onSourceEnded);\n            ms.removeEventListener('sourceclose', this.e.onSourceClose);\n            this._pendingSourceBufferInit = [];\n            this._isBufferFull = false;\n            this._idrList.clear();\n            this._mediaSource = null;\n        }\n\n        if (this._mediaElement) {\n            this._mediaElement.src = '';\n            this._mediaElement.removeAttribute('src');\n            this._mediaElement = null;\n        }\n        if (this._mediaSourceObjectURL) {\n            window.URL.revokeObjectURL(this._mediaSourceObjectURL);\n            this._mediaSourceObjectURL = null;\n        }\n    }\n\n    appendInitSegment(initSegment, deferred) {\n        if (!this._mediaSource || this._mediaSource.readyState !== 'open') {\n            // sourcebuffer creation requires mediaSource.readyState === 'open'\n            // so we defer the sourcebuffer creation, until sourceopen event triggered\n            this._pendingSourceBufferInit.push(initSegment);\n            // make sure that this InitSegment is in the front of pending segments queue\n            this._pendingSegments[initSegment.type].push(initSegment);\n            return;\n        }\n\n        let is = initSegment;\n        let mimeType = `${is.container}`;\n        if (is.codec && is.codec.length > 0) {\n            mimeType += `;codecs=${is.codec}`;\n        }\n\n        let firstInitSegment = false;\n\n        Log.v(this.TAG, 'Received Initialization Segment, mimeType: ' + mimeType);\n        this._lastInitSegments[is.type] = is;\n\n        if (mimeType !== this._mimeTypes[is.type]) {\n            if (!this._mimeTypes[is.type]) {  // empty, first chance create sourcebuffer\n                firstInitSegment = true;\n                try {\n                    let sb = this._sourceBuffers[is.type] = this._mediaSource.addSourceBuffer(mimeType);\n                    sb.addEventListener('error', this.e.onSourceBufferError);\n                    sb.addEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n                } catch (error) {\n                    Log.e(this.TAG, error.message);\n                    this._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n                    return;\n                }\n            } else {\n                Log.v(this.TAG, `Notice: ${is.type} mimeType changed, origin: ${this._mimeTypes[is.type]}, target: ${mimeType}`);\n            }\n            this._mimeTypes[is.type] = mimeType;\n        }\n\n        if (!deferred) {\n            // deferred means this InitSegment has been pushed to pendingSegments queue\n            this._pendingSegments[is.type].push(is);\n        }\n        if (!firstInitSegment) {  // append immediately only if init segment in subsequence\n            if (this._sourceBuffers[is.type] && !this._sourceBuffers[is.type].updating) {\n                this._doAppendSegments();\n            }\n        }\n        if (Browser.safari && is.container === 'audio/mpeg' && is.mediaDuration > 0) {\n            // 'audio/mpeg' track under Safari may cause MediaElement's duration to be NaN\n            // Manually correct MediaSource.duration to make progress bar seekable, and report right duration\n            this._requireSetMediaDuration = true;\n            this._pendingMediaDuration = is.mediaDuration / 1000;  // in seconds\n            this._updateMediaSourceDuration();\n        }\n    }\n\n    appendMediaSegment(mediaSegment) {\n        let ms = mediaSegment;\n        this._pendingSegments[ms.type].push(ms);\n\n        if (this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer()) {\n            this._doCleanupSourceBuffer();\n        }\n\n        let sb = this._sourceBuffers[ms.type];\n        if (sb && !sb.updating && !this._hasPendingRemoveRanges()) {\n            this._doAppendSegments();\n        }\n    }\n\n    seek(seconds) {\n        // remove all appended buffers\n        for (let type in this._sourceBuffers) {\n            if (!this._sourceBuffers[type]) {\n                continue;\n            }\n\n            // abort current buffer append algorithm\n            let sb = this._sourceBuffers[type];\n            if (this._mediaSource.readyState === 'open') {\n                try {\n                    // If range removal algorithm is running, InvalidStateError will be throwed\n                    // Ignore it.\n                    sb.abort();\n                } catch (error) {\n                    Log.e(this.TAG, error.message);\n                }\n            }\n\n            // IDRList should be clear\n            this._idrList.clear();\n\n            // pending segments should be discard\n            let ps = this._pendingSegments[type];\n            ps.splice(0, ps.length);\n\n            if (this._mediaSource.readyState === 'closed') {\n                // Parent MediaSource object has been detached from HTMLMediaElement\n                continue;\n            }\n\n            // record ranges to be remove from SourceBuffer\n            for (let i = 0; i < sb.buffered.length; i++) {\n                let start = sb.buffered.start(i);\n                let end = sb.buffered.end(i);\n                this._pendingRemoveRanges[type].push({start, end});\n            }\n\n            // if sb is not updating, let's remove ranges now!\n            if (!sb.updating) {\n                this._doRemoveRanges();\n            }\n\n            // Safari 10 may get InvalidStateError in the later appendBuffer() after SourceBuffer.remove() call\n            // Internal parser's state may be invalid at this time. Re-append last InitSegment to workaround.\n            // Related issue: https://bugs.webkit.org/show_bug.cgi?id=159230\n            if (Browser.safari) {\n                let lastInitSegment = this._lastInitSegments[type];\n                if (lastInitSegment) {\n                    this._pendingSegments[type].push(lastInitSegment);\n                    if (!sb.updating) {\n                        this._doAppendSegments();\n                    }\n                }\n            }\n        }\n    }\n\n    endOfStream() {\n        let ms = this._mediaSource;\n        let sb = this._sourceBuffers;\n        if (!ms || ms.readyState !== 'open') {\n            if (ms && ms.readyState === 'closed' && this._hasPendingSegments()) {\n                // If MediaSource hasn't turned into open state, and there're pending segments\n                // Mark pending endOfStream, defer call until all pending segments appended complete\n                this._hasPendingEos = true;\n            }\n            return;\n        }\n        if (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n            // If any sourcebuffer is updating, defer endOfStream operation\n            // See _onSourceBufferUpdateEnd()\n            this._hasPendingEos = true;\n        } else {\n            this._hasPendingEos = false;\n            // Notify media data loading complete\n            // This is helpful for correcting total duration to match last media segment\n            // Otherwise MediaElement's ended event may not be triggered\n            ms.endOfStream();\n        }\n    }\n\n    getNearestKeyframe(dts) {\n        return this._idrList.getLastSyncPointBeforeDts(dts);\n    }\n\n    _needCleanupSourceBuffer() {\n        if (!this._config.autoCleanupSourceBuffer) {\n            return false;\n        }\n\n        let currentTime = this._mediaElement.currentTime;\n\n        for (let type in this._sourceBuffers) {\n            let sb = this._sourceBuffers[type];\n            if (sb) {\n                let buffered = sb.buffered;\n                if (buffered.length >= 1) {\n                    if (currentTime - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    _doCleanupSourceBuffer() {\n        let currentTime = this._mediaElement.currentTime;\n\n        for (let type in this._sourceBuffers) {\n            let sb = this._sourceBuffers[type];\n            if (sb) {\n                let buffered = sb.buffered;\n                let doRemove = false;\n\n                for (let i = 0; i < buffered.length; i++) {\n                    let start = buffered.start(i);\n                    let end = buffered.end(i);\n\n                    if (start <= currentTime && currentTime < end + 3) {  // padding 3 seconds\n                        if (currentTime - start >= this._config.autoCleanupMaxBackwardDuration) {\n                            doRemove = true;\n                            let removeEnd = currentTime - this._config.autoCleanupMinBackwardDuration;\n                            this._pendingRemoveRanges[type].push({start: start, end: removeEnd});\n                        }\n                    } else if (end < currentTime) {\n                        doRemove = true;\n                        this._pendingRemoveRanges[type].push({start: start, end: end});\n                    }\n                }\n\n                if (doRemove && !sb.updating) {\n                    this._doRemoveRanges();\n                }\n            }\n        }\n    }\n\n    _updateMediaSourceDuration() {\n        let sb = this._sourceBuffers;\n        if (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== 'open') {\n            return;\n        }\n        if ((sb.video && sb.video.updating) || (sb.audio && sb.audio.updating)) {\n            return;\n        }\n\n        let current = this._mediaSource.duration;\n        let target = this._pendingMediaDuration;\n\n        if (target > 0 && (isNaN(current) || target > current)) {\n            Log.v(this.TAG, `Update MediaSource duration from ${current} to ${target}`);\n            this._mediaSource.duration = target;\n        }\n\n        this._requireSetMediaDuration = false;\n        this._pendingMediaDuration = 0;\n    }\n\n    _doRemoveRanges() {\n        for (let type in this._pendingRemoveRanges) {\n            if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n                continue;\n            }\n            let sb = this._sourceBuffers[type];\n            let ranges = this._pendingRemoveRanges[type];\n            while (ranges.length && !sb.updating) {\n                let range = ranges.shift();\n                sb.remove(range.start, range.end);\n            }\n        }\n    }\n\n    _doAppendSegments() {\n        let pendingSegments = this._pendingSegments;\n\n        for (let type in pendingSegments) {\n            if (!this._sourceBuffers[type] || this._sourceBuffers[type].updating) {\n                continue;\n            }\n\n            if (pendingSegments[type].length > 0) {\n                let segment = pendingSegments[type].shift();\n\n                if (segment.timestampOffset) {\n                    // For MPEG audio stream in MSE, if unbuffered-seeking occurred\n                    // We need explicitly set timestampOffset to the desired point in timeline for mpeg SourceBuffer.\n                    let currentOffset = this._sourceBuffers[type].timestampOffset;\n                    let targetOffset = segment.timestampOffset / 1000;  // in seconds\n\n                    let delta = Math.abs(currentOffset - targetOffset);\n                    if (delta > 0.1) {  // If time delta > 100ms\n                        Log.v(this.TAG, `Update MPEG audio timestampOffset from ${currentOffset} to ${targetOffset}`);\n                        this._sourceBuffers[type].timestampOffset = targetOffset;\n                    }\n                    delete segment.timestampOffset;\n                }\n\n                if (!segment.data || segment.data.byteLength === 0) {\n                    // Ignore empty buffer\n                    continue;\n                }\n\n                try {\n                    this._sourceBuffers[type].appendBuffer(segment.data);\n                    this._isBufferFull = false;\n                    if (type === 'video' && segment.hasOwnProperty('info')) {\n                        this._idrList.appendArray(segment.info.syncPoints);\n                    }\n                } catch (error) {\n                    this._pendingSegments[type].unshift(segment);\n                    if (error.code === 22) {  // QuotaExceededError\n                        /* Notice that FireFox may not throw QuotaExceededError if SourceBuffer is full\n                         * Currently we can only do lazy-load to avoid SourceBuffer become scattered.\n                         * SourceBuffer eviction policy may be changed in future version of FireFox.\n                         *\n                         * Related issues:\n                         * https://bugzilla.mozilla.org/show_bug.cgi?id=1279885\n                         * https://bugzilla.mozilla.org/show_bug.cgi?id=1280023\n                         */\n\n                        // report buffer full, abort network IO\n                        if (!this._isBufferFull) {\n                            this._emitter.emit(MSEEvents.BUFFER_FULL);\n                        }\n                        this._isBufferFull = true;\n                    } else {\n                        Log.e(this.TAG, error.message);\n                        this._emitter.emit(MSEEvents.ERROR, {code: error.code, msg: error.message});\n                    }\n                }\n            }\n        }\n    }\n\n    _onSourceOpen() {\n        Log.v(this.TAG, 'MediaSource onSourceOpen');\n        this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n        // deferred sourcebuffer creation / initialization\n        if (this._pendingSourceBufferInit.length > 0) {\n            let pendings = this._pendingSourceBufferInit;\n            while (pendings.length) {\n                let segment = pendings.shift();\n                this.appendInitSegment(segment, true);\n            }\n        }\n        // there may be some pending media segments, append them\n        if (this._hasPendingSegments()) {\n            this._doAppendSegments();\n        }\n        this._emitter.emit(MSEEvents.SOURCE_OPEN);\n    }\n\n    _onSourceEnded() {\n        // fired on endOfStream\n        Log.v(this.TAG, 'MediaSource onSourceEnded');\n    }\n\n    _onSourceClose() {\n        // fired on detaching from media element\n        Log.v(this.TAG, 'MediaSource onSourceClose');\n        if (this._mediaSource && this.e != null) {\n            this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n            this._mediaSource.removeEventListener('sourceended', this.e.onSourceEnded);\n            this._mediaSource.removeEventListener('sourceclose', this.e.onSourceClose);\n        }\n    }\n\n    _hasPendingSegments() {\n        let ps = this._pendingSegments;\n        return ps.video.length > 0 || ps.audio.length > 0;\n    }\n\n    _hasPendingRemoveRanges() {\n        let prr = this._pendingRemoveRanges;\n        return prr.video.length > 0 || prr.audio.length > 0;\n    }\n\n    _onSourceBufferUpdateEnd() {\n        if (this._requireSetMediaDuration) {\n            this._updateMediaSourceDuration();\n        } else if (this._hasPendingRemoveRanges()) {\n            this._doRemoveRanges();\n        } else if (this._hasPendingSegments()) {\n            this._doAppendSegments();\n        } else if (this._hasPendingEos) {\n            this.endOfStream();\n        }\n        this._emitter.emit(MSEEvents.UPDATE_END);\n    }\n\n    _onSourceBufferError(e) {\n        Log.e(this.TAG, `SourceBuffer Error: ${e}`);\n        // this error might not always be fatal, just ignore it\n    }\n\n}\n\nexport default MSEController;"]},"metadata":{},"sourceType":"module"}