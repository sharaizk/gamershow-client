{"ast":null,"code":"import _classCallCheck from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/STREAMING_SITE/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport decodeUTF8 from '../utils/utf8-conv.js';\nimport { IllegalStateException } from '../utils/exception.js';\n\nvar le = function () {\n  var buf = new ArrayBuffer(2);\n  new DataView(buf).setInt16(0, 256, true); // little-endian write\n\n  return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\n\nvar AMF = /*#__PURE__*/function () {\n  function AMF() {\n    _classCallCheck(this, AMF);\n  }\n\n  _createClass(AMF, null, [{\n    key: \"parseScriptData\",\n    value: function parseScriptData(arrayBuffer, dataOffset, dataSize) {\n      var data = {};\n\n      try {\n        var name = AMF.parseValue(arrayBuffer, dataOffset, dataSize);\n        var value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n        data[name.data] = value.data;\n      } catch (e) {\n        Log.e('AMF', e.toString());\n      }\n\n      return data;\n    }\n  }, {\n    key: \"parseObject\",\n    value: function parseObject(arrayBuffer, dataOffset, dataSize) {\n      if (dataSize < 3) {\n        throw new IllegalStateException('Data not enough when parse ScriptDataObject');\n      }\n\n      var name = AMF.parseString(arrayBuffer, dataOffset, dataSize);\n      var value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n      var isObjectEnd = value.objectEnd;\n      return {\n        data: {\n          name: name.data,\n          value: value.data\n        },\n        size: name.size + value.size,\n        objectEnd: isObjectEnd\n      };\n    }\n  }, {\n    key: \"parseVariable\",\n    value: function parseVariable(arrayBuffer, dataOffset, dataSize) {\n      return AMF.parseObject(arrayBuffer, dataOffset, dataSize);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(arrayBuffer, dataOffset, dataSize) {\n      if (dataSize < 2) {\n        throw new IllegalStateException('Data not enough when parse String');\n      }\n\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var length = v.getUint16(0, !le);\n      var str;\n\n      if (length > 0) {\n        str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n      } else {\n        str = '';\n      }\n\n      return {\n        data: str,\n        size: 2 + length\n      };\n    }\n  }, {\n    key: \"parseLongString\",\n    value: function parseLongString(arrayBuffer, dataOffset, dataSize) {\n      if (dataSize < 4) {\n        throw new IllegalStateException('Data not enough when parse LongString');\n      }\n\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var length = v.getUint32(0, !le);\n      var str;\n\n      if (length > 0) {\n        str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n      } else {\n        str = '';\n      }\n\n      return {\n        data: str,\n        size: 4 + length\n      };\n    }\n  }, {\n    key: \"parseDate\",\n    value: function parseDate(arrayBuffer, dataOffset, dataSize) {\n      if (dataSize < 10) {\n        throw new IllegalStateException('Data size invalid when parse Date');\n      }\n\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var timestamp = v.getFloat64(0, !le);\n      var localTimeOffset = v.getInt16(8, !le);\n      timestamp += localTimeOffset * 60 * 1000; // get UTC time\n\n      return {\n        data: new Date(timestamp),\n        size: 8 + 2\n      };\n    }\n  }, {\n    key: \"parseValue\",\n    value: function parseValue(arrayBuffer, dataOffset, dataSize) {\n      if (dataSize < 1) {\n        throw new IllegalStateException('Data not enough when parse Value');\n      }\n\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var offset = 1;\n      var type = v.getUint8(0);\n      var value;\n      var objectEnd = false;\n\n      try {\n        switch (type) {\n          case 0:\n            // Number(Double) type\n            value = v.getFloat64(1, !le);\n            offset += 8;\n            break;\n\n          case 1:\n            {\n              // Boolean type\n              var b = v.getUint8(1);\n              value = b ? true : false;\n              offset += 1;\n              break;\n            }\n\n          case 2:\n            {\n              // String type\n              var amfstr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n              value = amfstr.data;\n              offset += amfstr.size;\n              break;\n            }\n\n          case 3:\n            {\n              // Object(s) type\n              value = {};\n              var terminal = 0; // workaround for malformed Objects which has missing ScriptDataObjectEnd\n\n              if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                terminal = 3;\n              }\n\n              while (offset < dataSize - 4) {\n                // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n                var amfobj = AMF.parseObject(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);\n                if (amfobj.objectEnd) break;\n                value[amfobj.data.name] = amfobj.data.value;\n                offset += amfobj.size;\n              }\n\n              if (offset <= dataSize - 3) {\n                var marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n\n                if (marker === 9) {\n                  offset += 3;\n                }\n              }\n\n              break;\n            }\n\n          case 8:\n            {\n              // ECMA array type (Mixed array)\n              value = {};\n              offset += 4; // ECMAArrayLength(UI32)\n\n              var _terminal = 0; // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n\n              if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                _terminal = 3;\n              }\n\n              while (offset < dataSize - 8) {\n                // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n                var amfvar = AMF.parseVariable(arrayBuffer, dataOffset + offset, dataSize - offset - _terminal);\n                if (amfvar.objectEnd) break;\n                value[amfvar.data.name] = amfvar.data.value;\n                offset += amfvar.size;\n              }\n\n              if (offset <= dataSize - 3) {\n                var _marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n\n                if (_marker === 9) {\n                  offset += 3;\n                }\n              }\n\n              break;\n            }\n\n          case 9:\n            // ScriptDataObjectEnd\n            value = undefined;\n            offset = 1;\n            objectEnd = true;\n            break;\n\n          case 10:\n            {\n              // Strict array type\n              // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n              value = [];\n              var strictArrayLength = v.getUint32(1, !le);\n              offset += 4;\n\n              for (var i = 0; i < strictArrayLength; i++) {\n                var val = AMF.parseValue(arrayBuffer, dataOffset + offset, dataSize - offset);\n                value.push(val.data);\n                offset += val.size;\n              }\n\n              break;\n            }\n\n          case 11:\n            {\n              // Date type\n              var date = AMF.parseDate(arrayBuffer, dataOffset + 1, dataSize - 1);\n              value = date.data;\n              offset += date.size;\n              break;\n            }\n\n          case 12:\n            {\n              // Long string type\n              var amfLongStr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n              value = amfLongStr.data;\n              offset += amfLongStr.size;\n              break;\n            }\n\n          default:\n            // ignore and skip\n            offset = dataSize;\n            Log.w('AMF', 'Unsupported AMF value type ' + type);\n        }\n      } catch (e) {\n        Log.e('AMF', e.toString());\n      }\n\n      return {\n        data: value,\n        size: offset,\n        objectEnd: objectEnd\n      };\n    }\n  }]);\n\n  return AMF;\n}();\n\nexport default AMF;","map":{"version":3,"sources":["D:/STREAMING_SITE/client/node_modules/flv.js/src/demux/amf-parser.js"],"names":["Log","decodeUTF8","IllegalStateException","le","buf","ArrayBuffer","DataView","setInt16","Int16Array","AMF","arrayBuffer","dataOffset","dataSize","data","name","parseValue","value","size","e","toString","parseString","isObjectEnd","objectEnd","parseObject","v","length","getUint16","str","Uint8Array","getUint32","timestamp","getFloat64","localTimeOffset","getInt16","Date","offset","type","getUint8","b","amfstr","terminal","amfobj","marker","amfvar","parseVariable","undefined","strictArrayLength","i","val","push","date","parseDate","amfLongStr","w"],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Log from '../utils/logger.js';\nimport decodeUTF8 from '../utils/utf8-conv.js';\nimport {IllegalStateException} from '../utils/exception.js';\n\nlet le = (function () {\n    let buf = new ArrayBuffer(2);\n    (new DataView(buf)).setInt16(0, 256, true);  // little-endian write\n    return (new Int16Array(buf))[0] === 256;  // platform-spec read, if equal then LE\n})();\n\nclass AMF {\n\n    static parseScriptData(arrayBuffer, dataOffset, dataSize) {\n        let data = {};\n\n        try {\n            let name = AMF.parseValue(arrayBuffer, dataOffset, dataSize);\n            let value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n\n            data[name.data] = value.data;\n        } catch (e) {\n            Log.e('AMF', e.toString());\n        }\n\n        return data;\n    }\n\n    static parseObject(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 3) {\n            throw new IllegalStateException('Data not enough when parse ScriptDataObject');\n        }\n        let name = AMF.parseString(arrayBuffer, dataOffset, dataSize);\n        let value = AMF.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);\n        let isObjectEnd = value.objectEnd;\n\n        return {\n            data: {\n                name: name.data,\n                value: value.data\n            },\n            size: name.size + value.size,\n            objectEnd: isObjectEnd\n        };\n    }\n\n    static parseVariable(arrayBuffer, dataOffset, dataSize) {\n        return AMF.parseObject(arrayBuffer, dataOffset, dataSize);\n    }\n\n    static parseString(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 2) {\n            throw new IllegalStateException('Data not enough when parse String');\n        }\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n        let length = v.getUint16(0, !le);\n\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 2 + length\n        };\n    }\n\n    static parseLongString(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 4) {\n            throw new IllegalStateException('Data not enough when parse LongString');\n        }\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n        let length = v.getUint32(0, !le);\n\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 4 + length\n        };\n    }\n\n    static parseDate(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 10) {\n            throw new IllegalStateException('Data size invalid when parse Date');\n        }\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n        let timestamp = v.getFloat64(0, !le);\n        let localTimeOffset = v.getInt16(8, !le);\n        timestamp += localTimeOffset * 60 * 1000;  // get UTC time\n\n        return {\n            data: new Date(timestamp),\n            size: 8 + 2\n        };\n    }\n\n    static parseValue(arrayBuffer, dataOffset, dataSize) {\n        if (dataSize < 1) {\n            throw new IllegalStateException('Data not enough when parse Value');\n        }\n\n        let v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        let offset = 1;\n        let type = v.getUint8(0);\n        let value;\n        let objectEnd = false;\n\n        try {\n            switch (type) {\n                case 0:  // Number(Double) type\n                    value = v.getFloat64(1, !le);\n                    offset += 8;\n                    break;\n                case 1: {  // Boolean type\n                    let b = v.getUint8(1);\n                    value = b ? true : false;\n                    offset += 1;\n                    break;\n                }\n                case 2: {  // String type\n                    let amfstr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n                    value = amfstr.data;\n                    offset += amfstr.size;\n                    break;\n                }\n                case 3: { // Object(s) type\n                    value = {};\n                    let terminal = 0;  // workaround for malformed Objects which has missing ScriptDataObjectEnd\n                    if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (offset < dataSize - 4) {  // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n                        let amfobj = AMF.parseObject(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);\n                        if (amfobj.objectEnd)\n                            break;\n                        value[amfobj.data.name] = amfobj.data.value;\n                        offset += amfobj.size;\n                    }\n                    if (offset <= dataSize - 3) {\n                        let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            offset += 3;\n                        }\n                    }\n                    break;\n                }\n                case 8: { // ECMA array type (Mixed array)\n                    value = {};\n                    offset += 4;  // ECMAArrayLength(UI32)\n                    let terminal = 0;  // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n                    if ((v.getUint32(dataSize - 4, !le) & 0x00FFFFFF) === 9) {\n                        terminal = 3;\n                    }\n                    while (offset < dataSize - 8) {  // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n                        let amfvar = AMF.parseVariable(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);\n                        if (amfvar.objectEnd)\n                            break;\n                        value[amfvar.data.name] = amfvar.data.value;\n                        offset += amfvar.size;\n                    }\n                    if (offset <= dataSize - 3) {\n                        let marker = v.getUint32(offset - 1, !le) & 0x00FFFFFF;\n                        if (marker === 9) {\n                            offset += 3;\n                        }\n                    }\n                    break;\n                }\n                case 9:  // ScriptDataObjectEnd\n                    value = undefined;\n                    offset = 1;\n                    objectEnd = true;\n                    break;\n                case 10: {  // Strict array type\n                    // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n                    value = [];\n                    let strictArrayLength = v.getUint32(1, !le);\n                    offset += 4;\n                    for (let i = 0; i < strictArrayLength; i++) {\n                        let val = AMF.parseValue(arrayBuffer, dataOffset + offset, dataSize - offset);\n                        value.push(val.data);\n                        offset += val.size;\n                    }\n                    break;\n                }\n                case 11: {  // Date type\n                    let date = AMF.parseDate(arrayBuffer, dataOffset + 1, dataSize - 1);\n                    value = date.data;\n                    offset += date.size;\n                    break;\n                }\n                case 12: {  // Long string type\n                    let amfLongStr = AMF.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);\n                    value = amfLongStr.data;\n                    offset += amfLongStr.size;\n                    break;\n                }\n                default:\n                    // ignore and skip\n                    offset = dataSize;\n                    Log.w('AMF', 'Unsupported AMF value type ' + type);\n            }\n        } catch (e) {\n            Log.e('AMF', e.toString());\n        }\n\n        return {\n            data: value,\n            size: offset,\n            objectEnd: objectEnd\n        };\n    }\n\n}\n\nexport default AMF;"]},"metadata":{},"sourceType":"module"}